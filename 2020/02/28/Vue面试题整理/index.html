<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        刘晨曦的个人博客
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.3.0"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            Vue面试题整理
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h2 id="vue-指令"><a href="#vue-指令" class="headerlink" title="vue 指令"></a>vue 指令</h2><ul>
<li>解释：指令 (Directives) 是带有 v- 前缀的特殊属性。</li>
<li>作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</li>
</ul>
<hr>
<h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><ul>
<li>解释：更新元素的 textContent</li>
</ul>
<h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><ul>
<li>解释：更新元素的 innerHTML</li>
</ul>
<h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><ul>
<li>作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</li>
<li>语法：v-bind:title=”msg”</li>
<li>简写：:title=”msg”</li>
</ul>
<h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><ul>
<li>作用：绑定事件</li>
<li>语法：v-on:click=”say” or v-on:click=”say(‘参数’, $event)”</li>
<li>简写：@click=”say”</li>
<li>说明：绑定的事件从 methods 中获取</li>
</ul>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><ul>
<li>作用：在表单元素上创建双向数据绑定</li>
<li>说明：监听用户的输入事件以更新数据</li>
</ul>
<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><ul>
<li>作用：基于源数据多次渲染元素或模板块</li>
</ul>
<h3 id="v-if-和-v-show"><a href="#v-if-和-v-show" class="headerlink" title="v-if 和 v-show"></a>v-if 和 v-show</h3><ul>
<li>条件渲染</li>
<li>v-if：根据表达式的值的真假条件，销毁或重建元素</li>
<li>v-show：根据表达式之真假值，切换元素的 display CSS 属性</li>
</ul>
<h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h3><ul>
<li>限制：前一兄弟元素必须有 v-if 或 v-else-if。</li>
<li>用法：为 v-if 或者 v-else-if 添加“else 块”。</li>
</ul>
<h3 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h3><ul>
<li>限制：前一兄弟元素必须有 v-if 或 v-else-if。</li>
<li>表示 v-if 的“else if 块”。可以链式调用。</li>
</ul>
<h3 id="v-slot"><a href="#v-slot" class="headerlink" title="v-slot"></a>v-slot</h3><ul>
<li>用法：提供具名插槽或需要接收 prop 的插槽。</li>
<li>限用于：template 标签当中，组件 (对于一个单独的带 prop 的默认插槽)</li>
<li>参数：插槽名 (可选，默认值是 default)</li>
</ul>
<h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><ul>
<li>.stop 阻止冒泡，调用 event.stopPropagation()</li>
<li>.prevent 阻止默认事件，调用 event.preventDefault()</li>
<li>.capture 添加事件侦听器时使用事件捕获模式</li>
<li>.self 只当事件在该元素本身（比如不是子元素）触发时触发回调</li>
<li>.once 事件只触发一次</li>
</ul>
<h3 id="样式处理-class-和-style"><a href="#样式处理-class-和-style" class="headerlink" title="样式处理 -class 和 style"></a>样式处理 -class 和 style</h3><ul>
<li>说明：这两个都是 HTML 元素的属性，使用 v-bind，只需要通过表达式计算出字符串结果即可</li>
<li>表达式的类型：字符串、数组、对象</li>
</ul>
<h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><ul>
<li>用法：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</li>
</ul>
<h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><ul>
<li>用法：这个指令保持在元素上直到关联实例结束编译。和 CSS 规则一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</li>
</ul>
<h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><ul>
<li>用法：只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</li>
</ul>
<h2 id="Vue-插槽（slot）"><a href="#Vue-插槽（slot）" class="headerlink" title="Vue 插槽（slot）"></a>Vue 插槽（slot）</h2><ul>
<li>概念：是 Vue 提出来的一个概念，正如名字一样，插槽用于决定将所携带的内容，插入到指定的某个位置，从而使模板分块，具有模块化的特质和更大的重用性。</li>
<li>作用：为了让组件更加具有扩展性。抽取共性，保留不同为插槽，让其他组件可以传递自己想展示的标签到预留插槽。</li>
</ul>
<h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><ul>
<li>在组件中定义一个slot标签即可</li>
<li>如果插槽内具有共性的东西较多，可在插槽内设置默认值，当没有在插槽传入值时显示默认值</li>
<li>如果有多个值，同时放入到组件中进行替换时，一起作为替换元素</li>
</ul>
<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><blockquote>
<p>通常情况下，一个页面设计非常复杂，需要在一个页面的不同位置放入不同的插槽内容。那么在这种情况下，我们就需要给插槽 <slot> 指定一个具体的名称 name，使其具有具体匹配的特性，在 Vue 中把这种具有具体名称 name 的插槽.</slot></p>
</blockquote>
<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><blockquote>
<p>通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强程序的可靠性，减少名字冲突。</p>
</blockquote>
<h2 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>在 Vue 从创建实例到最终完全消亡的过程中，会执行一系列的方法，用于对应当前 Vue 的状态，这些方法我们叫它：生命周期钩子！</p>
</blockquote>
<h3 id="8-个生命周期函数"><a href="#8-个生命周期函数" class="headerlink" title="8 个生命周期函数"></a>8 个生命周期函数</h3><ol>
<li>beforeCreate：在实例初始化之后。</li>
<li>created：在实例创建完成后被立即调用。</li>
<li>beforeMount：在挂载开始之前被调用，相关的 render 函数首次被调用。</li>
<li>mounted：el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。</li>
<li>beforeUpdate：数据更新时调用。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</li>
<li>updated：数据更新之后调用。</li>
<li>beforeDestroy：实例销毁之前调用，在这一步，实例仍然完全可用。</li>
<li>destroyed：Vue 实例销毁后调用。</li>
</ol>
<h3 id="3-个关于-vue-组件的生命周期钩子"><a href="#3-个关于-vue-组件的生命周期钩子" class="headerlink" title="3 个关于 vue 组件的生命周期钩子"></a>3 个关于 vue 组件的生命周期钩子</h3><ol>
<li>activated：keep-alive 组件激活时调用</li>
<li>deactivated：keep-alive 组件停用时调用</li>
<li>errorCaptured：当捕获一个来自子孙组件的错误时被调用。<br>此钩子会收到 3 个参数：<ul>
<li>错误对象</li>
<li>发生错误的组件实例</li>
<li>一个包含错误来源信息的字符串<br>返回值：此钩子可以返回 false 以阻止该错误继续向上传播。</li>
</ul>
</li>
</ol>
<h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><ul>
<li>概念：keep-alive 是一个内置抽象组件（它自身不会渲染一个 DOM 元素，也不会出现在父组件链中，abstract: true 属性值决定）。</li>
<li>作用：包裹动态组件时，会缓存不活动的组件实例。而不是销毁它们。 其主要用于保留组件状态（保留在内存中），避免重新渲染。</li>
</ul>
<hr>
<h3 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h3><ol>
<li>从列表进入详情页面，再回到列表页面，不需要刷新列表页面</li>
<li>填写表单，进入下一步，返回上一步数据不会清空</li>
<li>长列表内容</li>
</ol>
<h3 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h3><p>有三个属性 Props：</p>
<ul>
<li>include 字符串或正则表达式。只有名称匹配的组件会被缓存。</li>
<li>exclude 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li>
<li>max 最多可以缓存多少组件实例。</li>
</ul>
<h3 id="常见面试题："><a href="#常见面试题：" class="headerlink" title="常见面试题："></a>常见面试题：</h3><p>本文引自：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6921158170224099335#heading-4">https://juejin.cn/post/6921158170224099335#heading-4</a></p>
<h2 id="谈一谈-Vuex"><a href="#谈一谈-Vuex" class="headerlink" title="谈一谈 Vuex"></a>谈一谈 Vuex</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式,可以帮助我们管理共享状态。<br>Vuex 是实现组件全局状态(数据) 管理的一种机制，可以方便的实现组件之间数据的共享。</p>
<h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><p>Vuex 的组成部分如下：</p>
<ol>
<li>state：State 提供唯一的公共数据源，所有共享的数据都要统一放到 Store 的 State 中进行存储</li>
<li>mutations：用于变更 Store 中的数据</li>
</ol>
<ul>
<li>不能直接改变 store 仓库中的状态</li>
<li>改变 store 中的状态唯一途径就是显示地提交 mutation。</li>
<li>这样使得我们可以方便地跟踪每一个状态地变化，从而让我们能够实现一些工具帮助我们更好地了解我们地应用。</li>
</ul>
<ol start="3">
<li>actions：用于处理异步任务。如果通过异步操作变更数据，必须通过 Action，而不能使用 Mutation，但是在 Action 中还是要通过触发 Mutation 的方式间接变更数据。</li>
<li>getters：用于对 Store 中的数据进行加工处理形成新的数据。</li>
</ol>
<ul>
<li>getters 可以对 Store 中已有的数据加工处理之后形成新的数据,类似 Vue 的计算属性</li>
<li>Store 中数据发生变化，Getter 的数据也会跟着变化</li>
</ul>
<ol start="5">
<li>modules：拆分，方便多人协同开发。</li>
</ol>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>能够在 vuex 中集中管理共享的数据，易于开发和后期维护</li>
<li>能够高效地实现组件之间的数据共享，提高开发效率</li>
<li>存储在 vuex 中的数据都是响应式的，能够实时保持数据与页面的同步。</li>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>一般情况下，只有组件之间共享的数据，才有必要存储到 vuex 中；对于组件中的私有数据，依旧存储在组件自身的 data 中即可。</p>
<h2 id="Vue-异步组件"><a href="#Vue-异步组件" class="headerlink" title="Vue 异步组件"></a>Vue 异步组件</h2><h3 id="普通函数异步组件"><a href="#普通函数异步组件" class="headerlink" title="普通函数异步组件"></a>普通函数异步组件</h3><h3 id="Promise异步组件"><a href="#Promise异步组件" class="headerlink" title="Promise异步组件"></a>Promise异步组件</h3><h3 id="高级异步组件"><a href="#高级异步组件" class="headerlink" title="高级异步组件"></a>高级异步组件</h3><h2 id="Vue-事件总线（EventBus）"><a href="#Vue-事件总线（EventBus）" class="headerlink" title="Vue 事件总线（EventBus）"></a>Vue 事件总线（EventBus）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>EventBus 又称为事件总线。在 Vue 中可以使用 EventBus 来作为沟通桥梁的概念，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件。</p>
<h3 id="使用以及注意事项"><a href="#使用以及注意事项" class="headerlink" title="使用以及注意事项"></a>使用以及注意事项</h3><p>新创建一个 event-bus.js 文件;<br>首先需要创建事件总线并将其导出，以便其它组件可以使用或者监听它。<br>然后假设你有两个 Vue 组件 A 和 B,A 组件需要通知 B 组件。<br>最后分别在两个组件中引入 EventBus<br><strong>发送：</strong> A 组件通过 EventBus.$emit(事件名,payload)发送；<br><strong>接收：</strong> B 组件通过 EventBus.$on(事件名,payload)接收；<br><strong>移除：</strong></p>
<ol>
<li>通过 EventBus.$off(事件名)来移除应用内所有对此某个事件的监听</li>
<li>直接调用 EventBus.$off() 来移除所有事件频道，不需要添加任何参数 。</li>
</ol>
<p><span style="color:red;font-size:16px;">注意事项：</span></p>
<ol>
<li>如果你在某一个组件刷新了之后，与之相关的 EventBus 会被移除，这样就导致业务走不下去。</li>
<li>如果业务有反复操作的组件，EventBus 在监听的时候就会触发很多次，也是一个非常大的隐患。</li>
</ol>
<p><span style="color:blue;font-size:16px;">解决方法：</span></p>
<p><strong>在 vue 组件销毁时，同时移除 EventBus 事件监听。</strong></p>
<h2 id="Vuex-与全局对象的区别"><a href="#Vuex-与全局对象的区别" class="headerlink" title="Vuex 与全局对象的区别"></a>Vuex 与全局对象的区别</h2><h2 id="Vue-router-相关问题"><a href="#Vue-router-相关问题" class="headerlink" title="Vue-router 相关问题"></a>Vue-router 相关问题</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ol>
<li>vue-router 是 WebApp 的链接路径管理系统。</li>
<li>vue-router 是 Vue.js 官方的路由插件，它和 vue.js 是深度集成的，适合用于构建单页面应用。</li>
</ol>
<h3 id="它与传统的页面跳转的区别"><a href="#它与传统的页面跳转的区别" class="headerlink" title="它与传统的页面跳转的区别"></a>它与传统的页面跳转的区别</h3><ol>
<li>vue 的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来（一个 url 地址对应着一个组件）。</li>
<li>传统的页面应用，是用一些超链接来实现页面切换和跳转的。</li>
</ol>
<blockquote>
<p>换而言之在 vue-router 单页面应用中，则是路径之间的切换，也就是组件的切换。路由模块的本质 就是建立起 url 和页面之间的映射关系。</p>
</blockquote>
<h3 id="为什么使用-vue-router"><a href="#为什么使用-vue-router" class="headerlink" title="为什么使用 vue-router"></a>为什么使用 vue-router</h3><blockquote>
<p>我们为什么不能使用 a 标签代替，这是因为用 Vue 做的都是单页面应用（当你的项目准备打包时，运行 npm run build 时，就会生成 dist 文件夹，这里面只有静态资源和一个 index.html 页面，在没有后端服务的支持下，浏览器无法找到对应的 url 路径的），所以你写的标签是不起作用的，你必须使用 vue-router 来进行管理。</p>
</blockquote>
<ul>
<li>vue-router 的功能</li>
</ul>
<ol>
<li>嵌套的路由/视图表</li>
<li>模块化的、基于组件的路由配置</li>
<li>路由参数、查询、通配符</li>
<li>基于 Vue.js 过渡系统的视图过渡效果</li>
<li>HTML5 history 模式或 hash 模式，在 IE9 中自动降级。</li>
</ol>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>单页面应用(SPA)的核心之一是:</p>
<ol>
<li>更新视图而不重新请求页面</li>
<li>vue-router 在实现单页面前端路由时，提供了三种方式： Hash 模式;History 模式;根据 mode 参数以及运行环境决定采用哪一种方式。</li>
</ol>
<hr>
<h5 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h5><ul>
<li>vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</li>
<li>hash 模式的原理是 onhashchange 事件(监测 hash 值变化)，可以在 window 对象上监听这个事件。</li>
</ul>
<h5 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h5><blockquote>
<p>html5 history interface 中新增的了 pushState() 和 replaceState()方法这两个方法应用于浏览器记录栈，在当前已有的 back、forward、go 基础之上，它们提供了对历史记录修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。同时还有 popstate 事件。通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。</p>
</blockquote>
<h5 id="history-模式，页面返回-404"><a href="#history-模式，页面返回-404" class="headerlink" title="history 模式，页面返回 404"></a>history 模式，页面返回 404</h5><ul>
<li><p>问题原因：因为 history 模式是 html5 新增特性，它的功能只是来改变浏览器地址栏里的路径，并没有发起 http 请求，但是当我直接在浏览器里输入这个地址的时候，就一定要对服务器发起 http 请求，但是这个目标在服务器上又不存在， 所以会返回 404。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。</p>
</li>
<li><p>具体做法：要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</p>
</li>
</ul>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020 <a class="flink" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>-<a class="flink" target="_blank" rel="noopener" href="https://github.com/sanjinhub/hexo-theme-geek">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="FqiyUqbg7McKN2eG0MCewupf">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>