<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        刘晨曦的个人博客
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.3.0"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            阐述深浅拷贝
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>说起深浅拷贝离不开JavaScript的基本类型，我们首先说说JavaScript的数据类型与复制两种数据类型的区别。</p>
<h3 id="1、JS数据类型"><a href="#1、JS数据类型" class="headerlink" title="1、JS数据类型"></a>1、JS数据类型</h3><p>javaScritp的数据类型有：数值类型、字符串类型、布尔类型、空、undefined、对象(数组、正则表达式、日期、函数)，大致分成两种：基本数据类型和引用数据类型。<br>1、基本数据类型：数值、字符串、布尔、空、undefined （值类型）、symbol(ES6新增)<br>2、复杂(复合)数据类型：对象 (引用类型)；<br><strong>基本数据类型</strong>保存在<strong>栈内存</strong>，<strong>引用类型</strong>保存在<strong>堆内存</strong>中。<br><strong>根本原因</strong>在于保存在栈内存的必须是大小固定的数据，引用类型的大小不固定，只能保存在堆内存中，但是可以把它的地址写在栈内存中以供我们访问。<br><strong>如果是基本数据类型，则按值访问，操作的就是变量保存的值；如果是引用类型的值，我们只是通过保存在变量中的引用类型的地址来操作实际对象。</strong></p>
<h3 id="2、复制基本类型数据"><a href="#2、复制基本类型数据" class="headerlink" title="2、复制基本类型数据"></a>2、复制基本类型数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">var b &#x3D; a;&#x2F;&#x2F;复制</span><br><span class="line">console.log(b)&#x2F;&#x2F;1；</span><br><span class="line">a &#x3D; 2;&#x2F;&#x2F;改变a的值</span><br><span class="line">console.log(b)&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>
<p><strong>赋值的时候，在栈内存中重新开辟内存，存放变量b，所以在栈内存中分别存放着变量a、b各自的值，修改时互不影响。</strong></p>
<h3 id="3、复制复杂类型的数据"><a href="#3、复制复杂类型的数据" class="headerlink" title="3、复制复杂类型的数据"></a>3、复制复杂类型的数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var color1 &#x3D; [&#39;red&#39;,&#39;green&#39;];</span><br><span class="line">var color2 &#x3D; color1;&#x2F;&#x2F;复制</span><br><span class="line">console.log(color2)&#x2F;&#x2F;[&#39;red&#39;,&#39;green&#39;];</span><br><span class="line">color1.push(&#39;black&#39;) ;&#x2F;&#x2F;改变color1的值</span><br><span class="line">console.log(color2)&#x2F;&#x2F;[&#39;red&#39;,&#39;green&#39;,&#39;black&#39;]</span><br></pre></td></tr></table></figure>
<p><strong>color1与color2指向堆内存中同一地址的同一对象，复制的只是引用地址</strong><br><strong>因此，对于引用类型的复制，简单赋值无用，需要拷贝。拷贝存在两种类型：深拷贝与浅拷贝</strong></p>
<h2 id="深浅拷贝的应用"><a href="#深浅拷贝的应用" class="headerlink" title="深浅拷贝的应用"></a>深浅拷贝的应用</h2><h3 id="1、浅拷贝的实现方式"><a href="#1、浅拷贝的实现方式" class="headerlink" title="1、浅拷贝的实现方式"></a>1、浅拷贝的实现方式</h3><p>（1）<strong>Object.assign()</strong><br><code>可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。</code><br>（2）<strong>lodash的clone方法</strong><br>（3）<code>...操作符</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;Kobei&#x27;</span>, <span class="attr">address</span>:&#123;<span class="attr">x</span>:<span class="number">100</span>,<span class="attr">y</span>:<span class="number">100</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> obj2= &#123;... obj1&#125;</span><br><span class="line">obj1.address.x = <span class="number">200</span>;</span><br><span class="line">obj1.name = <span class="string">&#x27;wade&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;obj2&#x27;</span>,obj2) <span class="comment">// obj2 &#123; name: &#x27;Kobe&#x27;, address: &#123; x: 200, y: 100 &#125; &#125;</span></span><br></pre></td></tr></table></figure>
<p>（4）<strong>Array.prototype.concat</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123;</span><br><span class="line">    username: <span class="string">&#x27;kobe&#x27;</span></span><br><span class="line">    &#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.concat();    </span><br><span class="line">arr2[<span class="number">2</span>].username = <span class="string">&#x27;wade&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>
<p>（5）<strong>Array.prototype.slice</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123;<span class="number">2</span></span><br><span class="line">    username: <span class="string">&#x27; kobe&#x27;</span></span><br><span class="line">    &#125;];</span><br><span class="line"><span class="keyword">let</span> arr3 = arr.slice();</span><br><span class="line">arr3[<span class="number">2</span>].username = <span class="string">&#x27;wade&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 3, &#123; username: &#x27;wade&#x27; &#125; ]</span></span><br></pre></td></tr></table></figure>
<h3 id="2、深拷贝的实现方式"><a href="#2、深拷贝的实现方式" class="headerlink" title="2、深拷贝的实现方式"></a>2、深拷贝的实现方式</h3><p>（1）<strong>JSON.parse(JSON.stringify())</strong><br>  可以处理数组和对象的深拷贝，但是不能处理函数和正则，因为这两者基于这两个函数处理后得到的结果不再是正则/函数**<br>  <strong>缺点：</strong><br>  <ul><br>    <li>会忽略undefined</li><br>    <li>会忽略symbol</li><br>    <li>不能序列化函数</li><br>    <li>不能解决循环引用的对象</li><br>  </ul>  </p>
<p>（2）<strong>lodash的cloneDeep函数</strong><br>（3）<strong>jQuery.extend函数</strong><br>（4）<strong>如果所拷贝的对象含有内置对象，但是不包含函数，可以使用<code>messagechannel</code>，可以拷贝undefined和循环引用的对象</strong><br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function structuralClone(obj) &#123;</span><br><span class="line">  return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">    const &#123; port1, port2 &#125; &#x3D; new MessageChannel()</span><br><span class="line">    port2.onmessage &#x3D; ev &#x3D;&gt; resolve(ev.data)</span><br><span class="line">    port1.postMessage(obj)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b.d &#x3D; obj.b</span><br><span class="line">&#x2F;&#x2F; 注意该方法是异步的</span><br><span class="line">&#x2F;&#x2F; 可以处理 undefined 和循环引用对象</span><br><span class="line">const test &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">  const clone &#x3D; await structuralClone(obj)</span><br><span class="line">  console.log(clone)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure></p>
<h3 id="3、手写浅拷贝：遍历-gt-直接等号赋值"><a href="#3、手写浅拷贝：遍历-gt-直接等号赋值" class="headerlink" title="3、手写浅拷贝：遍历=&gt;直接等号赋值"></a>3、手写浅拷贝：遍历=&gt;直接等号赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name : <span class="string">&#x27;深深地&#x27;</span>,</span><br><span class="line">    arr : [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj3=shallowClone(obj1)</span><br><span class="line"></span><br><span class="line">obj3.name = <span class="string">&quot;春娇&quot;</span>;</span><br><span class="line">obj3.arr[<span class="number">1</span>] = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] ; <span class="comment">// 新旧对象还是共享同一块内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是个浅拷贝的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowClone</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source.hasOwnProperty(i)) &#123;</span><br><span class="line">            target[i] = source[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;obj1&#x27;</span>,obj1) <span class="comment">// obj1 &#123; name: &#x27;深深地&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;obj3&#x27;</span>,obj3) <span class="comment">// obj3 &#123; name: &#x27;春娇&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;obj.hasOwnProperty，返回值是一个布尔值，即是否是obj的属性（原型上的是false)</span></span><br></pre></td></tr></table></figure>
    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020 <a class="flink" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>-<a class="flink" target="_blank" rel="noopener" href="https://github.com/sanjinhub/hexo-theme-geek">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="FqiyUqbg7McKN2eG0MCewupf">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>