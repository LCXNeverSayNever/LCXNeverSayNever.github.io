<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>TypeScript-接口和类 | 刘晨曦的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="接口介绍TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 接口初探下面通过一个简单示例来观察接口是如何工作的： function printLabel(labelledObj: { label: string }) {  console.lo">
<meta property="og:type" content="article">
<meta property="og:title" content="TypeScript-接口和类">
<meta property="og:url" content="http://example.com/2019/10/31/TypeScript-%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB/index.html">
<meta property="og:site_name" content="刘晨曦的个人博客">
<meta property="og:description" content="接口介绍TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 接口初探下面通过一个简单示例来观察接口是如何工作的： function printLabel(labelledObj: { label: string }) {  console.lo">
<meta property="og:locale">
<meta property="article:published_time" content="2019-10-31T11:41:39.000Z">
<meta property="article:modified_time" content="2021-03-10T12:22:58.720Z">
<meta property="article:author" content="刘晨曦的个人博客">
<meta property="article:tag" content="TS">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="刘晨曦的个人博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">刘晨曦的个人博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-TypeScript-接口和类" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/31/TypeScript-%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB/" class="article-date">
  <time class="dt-published" datetime="2019-10-31T11:41:39.000Z" itemprop="datePublished">2019-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      TypeScript-接口和类
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>
<h3 id="接口初探"><a href="#接口初探" class="headerlink" title="接口初探"></a>接口初探</h3><p>下面通过一个简单示例来观察接口是如何工作的：</p>
<p>function printLabel(labelledObj: { label: string }) {<br>  console.log(labelledObj.label);<br>}</p>
<p>let myObj = { size: 10, label: “Size 10 Object” };<br>printLabel(myObj);<br>类型检查器会查看printLabel的调用。 printLabel有一个参数，并要求这个对象参数有一个名为label类型为string的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候TypeScript却并不会这么宽松，我们下面会稍做讲解。</p>
<p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个label属性且类型为string：</p>
<p>interface LabelledValue {<br>  label: string;<br>}</p>
<p>function printLabel(labelledObj: LabelledValue) {<br>  console.log(labelledObj.label);<br>}</p>
<p>let myObj = {size: 10, label: “Size 10 Object”};<br>printLabel(myObj);<br>LabelledValue接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 label属性且类型为string的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 printLabel的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p>
<p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p>
<h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p>
<p>下面是应用了“option bags”的例子：</p>
<p>interface SquareConfig {<br>  color?: string;<br>  width?: number;<br>}</p>
<p>function createSquare(config: SquareConfig): {color: string; area: number} {<br>  let newSquare = {color: “white”, area: 100};<br>  if (config.color) {<br>    newSquare.color = config.color;<br>  }<br>  if (config.width) {<br>    newSquare.area = config.width * config.width;<br>  }<br>  return newSquare;<br>}</p>
<p>let mySquare = createSquare({color: “black”});<br>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。</p>
<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare里的color属性名拼错，就会得到一个错误提示：</p>
<p>interface SquareConfig {<br>  color?: string;<br>  width?: number;<br>}</p>
<p>function createSquare(config: SquareConfig): { color: string; area: number } {<br>  let newSquare = {color: “white”, area: 100};<br>  if (config.clor) {<br>    // Error: Property ‘clor’ does not exist on type ‘SquareConfig’<br>    newSquare.color = config.clor;<br>  }<br>  if (config.width) {<br>    newSquare.area = config.width * config.width;<br>  }<br>  return newSquare;<br>}</p>
<p>let mySquare = createSquare({color: “black”});</p>
<h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:</p>
<p>interface Point {<br>    readonly x: number;<br>    readonly y: number;<br>}<br>你可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。</p>
<p>let p1: Point = { x: 10, y: 20 };<br>p1.x = 5; // error!<br>TypeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</T></T></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let a: number[] &#x3D; [1, 2, 3, 4];</span><br><span class="line">let ro: ReadonlyArray&lt;number&gt; &#x3D; a;</span><br><span class="line">ro[0] &#x3D; 12; &#x2F;&#x2F; error!</span><br><span class="line">ro.push(5); &#x2F;&#x2F; error!</span><br><span class="line">ro.length &#x3D; 100; &#x2F;&#x2F; error!</span><br><span class="line">a &#x3D; ro; &#x2F;&#x2F; error!</span><br><span class="line">上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</span><br><span class="line"></span><br><span class="line">a &#x3D; ro as number[];</span><br><span class="line">readonly vs const</span><br></pre></td></tr></table></figure>
<p>最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。</p>
<h3 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h3><p>我们在第一个例子里使用了接口，TypeScript让我们传入{ size: number; label: string; }到仅期望得到{ label: string; }的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。</p>
<p>然而，天真地将这两者结合的话就会像在JavaScript里那样搬起石头砸自己的脚。 比如，拿 createSquare例子来说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">    color?: string;</span><br><span class="line">    width?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySquare &#x3D; createSquare(&#123; colour: &quot;red&quot;, width: 100 &#125;);</span><br></pre></td></tr></table></figure>
<p>注意传入createSquare的参数拼写为colour而不是color。 在JavaScript里，这会默默地失败。</p>
<p>你可能会争辩这个程序已经正确地类型化了，因为width属性是兼容的，不存在color属性，而且额外的colour属性是无意义的。</p>
<p>然而，TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p>
<p>// error: ‘colour’ not expected in type ‘SquareConfig’<br>let mySquare = createSquare({ colour: “red”, width: 100 });<br>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p>
<p>let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);<br>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：</p>
<p>interface SquareConfig {<br>    color?: string;<br>    width?: number;<br>    [propName: string]: any;<br>}<br>我们稍后会讲到索引签名，但在这我们要表示的是SquareConfig可以有任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。</p>
<p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 squareOptions不会经过额外属性检查，所以编译器不会报错。</p>
<p>let squareOptions = { colour: “red”, width: 100 };<br>let mySquare = createSquare(squareOptions);<br>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入 color或colour属性到createSquare，你应该修改SquareConfig定义来体现出这一点。</p>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<p>interface SearchFunc {<br>  (source: string, subString: string): boolean;<br>}</p>
<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>
<p>let mySearch: SearchFunc;<br>mySearch = function(source: string, subString: string) {<br>  let result = source.search(subString);<br>  return result &gt; -1;<br>}<br>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p>
<p>let mySearch: SearchFunc;<br>mySearch = function(src: string, sub: string): boolean {<br>  let result = src.search(sub);<br>  return result &gt; -1;<br>}<br>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false和true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 SearchFunc接口中的定义不匹配。</p>
<p>let mySearch: SearchFunc;<br>mySearch = function(src, sub) {<br>    let result = src.search(sub);<br>    return result &gt; -1;<br>}</p>
<h3 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h3><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[“daniel”]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p>
<p>interface StringArray {<br>  [index: number]: string;<br>}</p>
<p>let myArray: StringArray;<br>myArray = [“Bob”, “Fred”];</p>
<p>let myStr: string = myArray[0];</p>
<p>上面例子里，我们定义了StringArray接口，它具有索引签名。 这个索引签名表示了当用 number去索引StringArray时会得到string类型的返回值。</p>
<p>TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。</p>
<p>class Animal {<br>    name: string;<br>}<br>class Dog extends Animal {<br>    breed: string;<br>}</p>
<p>// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!<br>interface NotOkay {<br>    [x: number]: Animal;<br>    [x: string]: Dog;<br>}<br>字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property和obj[“property”]两种形式都可以。 下面的例子里， name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>
<p>interface NumberDictionary {<br>  [index: string]: number;<br>  length: number;    // 可以，length是number类型<br>  name: string       // 错误，<code>name</code>的类型与索引类型返回值的类型不匹配<br>}<br>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>
<p>interface ReadonlyStringArray {<br>    readonly [index: number]: string;<br>}<br>let myArray: ReadonlyStringArray = [“Alice”, “Bob”];<br>myArray[2] = “Mallory”; // error!<br>你不能设置myArray[2]，因为索引签名是只读的。</p>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>实现接口<br>与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。</p>
<p>interface ClockInterface {<br>    currentTime: Date;<br>}</p>
<p>class Clock implements ClockInterface {<br>    currentTime: Date;<br>    constructor(h: number, m: number) { }<br>}<br>你也可以在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样：</p>
<p>interface ClockInterface {<br>    currentTime: Date;<br>    setTime(d: Date);<br>}</p>
<p>class Clock implements ClockInterface {<br>    currentTime: Date;<br>    setTime(d: Date) {<br>        this.currentTime = d;<br>    }<br>    constructor(h: number, m: number) { }<br>}<br>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p>
<p>类静态部分与实例部分的区别<br>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p>
<p>interface ClockConstructor {<br>    new (hour: number, minute: number);<br>}</p>
<p>class Clock implements ClockConstructor {<br>    currentTime: Date;<br>    constructor(h: number, m: number) { }<br>}</p>
<p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。</p>
<p>因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口， ClockConstructor为构造函数所用和ClockInterface为实例方法所用。 为了方便我们定义一个构造函数 createClock，它用传入的类型创建实例。</p>
<p>interface ClockConstructor {<br>    new (hour: number, minute: number): ClockInterface;<br>}<br>interface ClockInterface {<br>    tick();<br>}</p>
<p>function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {<br>    return new ctor(hour, minute);<br>}</p>
<p>class DigitalClock implements ClockInterface {<br>    constructor(h: number, m: number) { }<br>    tick() {<br>        console.log(“beep beep”);<br>    }<br>}<br>class AnalogClock implements ClockInterface {<br>    constructor(h: number, m: number) { }<br>    tick() {<br>        console.log(“tick tock”);<br>    }<br>}</p>
<p>let digital = createClock(DigitalClock, 12, 17);<br>let analog = createClock(AnalogClock, 7, 32);<br>因为createClock的第一个参数是ClockConstructor类型，在createClock(AnalogClock, 7, 32)里，会检查AnalogClock是否符合构造函数签名。</p>
<h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<p>interface Shape {<br>    color: string;<br>}</p>
<p>interface Square extends Shape {<br>    sideLength: number;<br>}</p>
<p>let square = <Square>{};<br>square.color = “blue”;<br>square.sideLength = 10;<br>一个接口可以继承多个接口，创建出多个接口的合成接口。</Square></p>
<p>interface Shape {<br>    color: string;<br>}</p>
<p>interface PenStroke {<br>    penWidth: number;<br>}</p>
<p>interface Square extends Shape, PenStroke {<br>    sideLength: number;<br>}</p>
<p>let square = <Square>{};<br>square.color = “blue”;<br>square.sideLength = 10;<br>square.penWidth = 5.0;<br>混合类型<br>先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</Square></p>
<p>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p>
<p>interface Counter {<br>    (start: number): string;<br>    interval: number;<br>    reset(): void;<br>}</p>
<p>function getCounter(): Counter {<br>    let counter = <Counter>function (start: number) { };<br>    counter.interval = 123;<br>    counter.reset = function () { };<br>    return counter;<br>}</Counter></p>
<p>let c = getCounter();<br>c(10);<br>c.reset();<br>c.interval = 5.0;<br>在使用JavaScript第三方库的时候，你可能需要像上面那样去完整地定义类型。</p>
<h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p>
<p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。 例：</p>
<p>class Control {<br>    private state: any;<br>}</p>
<p>interface SelectableControl extends Control {<br>    select(): void;<br>}</p>
<p>class Button extends Control implements SelectableControl {<br>    select() { }<br>}</p>
<p>class TextBox extends Control {<br>    select() { }<br>}</p>
<p>// 错误：“Image”类型缺少“state”属性。<br>class Image implements SelectableControl {<br>    select() { }<br>}</p>
<p>class Location {</p>
<p>}<br>在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为 state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有 Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。</p>
<p>在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上， SelectableControl接口和拥有select方法的Control类是一样的。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。</p>
<h3 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h3><p>下面看一个使用类的例子：</p>
<p>class Greeter {<br>    greeting: string;<br>    constructor(message: string) {<br>        this.greeting = message;<br>    }<br>    greet() {<br>        return “Hello, “ + this.greeting;<br>    }<br>}</p>
<p>let greeter = new Greeter(“world”);<br>如果你使用过C#或Java，你会对这种语法非常熟悉。 我们声明一个 Greeter类。这个类有3个成员：一个叫做 greeting的属性，一个构造函数和一个 greet方法。</p>
<p>你会注意到，我们在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。</p>
<p>最后一行，我们使用 new构造了 Greeter类的一个实例。 它会调用之前定义的构造函数，创建一个 Greeter类型的新对象，并执行构造函数初始化它。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p>
<p>看下面的例子：</p>
<p>class Animal {<br>    move(distanceInMeters: number = 0) {<br>        console.log(<code>Animal moved $&#123;distanceInMeters&#125;m.</code>);<br>    }<br>}</p>
<p>class Dog extends Animal {<br>    bark() {<br>        console.log(‘Woof! Woof!’);<br>    }<br>}</p>
<p>const dog = new Dog();<br>dog.bark();<br>dog.move(10);<br>dog.bark();<br>这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里， Dog是一个 派生类，它派生自 Animal 基类，通过 extends关键字。 派生类通常被称作 子类，基类通常被称作 超类。</p>
<p>因为 Dog继承了 Animal的功能，因此我们可以创建一个 Dog的实例，它能够 bark()和 move()。</p>
<p>下面我们来看个更加复杂的例子。</p>
<p>class Animal {<br>    name: string;<br>    constructor(theName: string) { this.name = theName; }<br>    move(distanceInMeters: number = 0) {<br>        console.log(<code>$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.</code>);<br>    }<br>}</p>
<p>class Snake extends Animal {<br>    constructor(name: string) { super(name); }<br>    move(distanceInMeters = 5) {<br>        console.log(“Slithering…”);<br>        super.move(distanceInMeters);<br>    }<br>}</p>
<p>class Horse extends Animal {<br>    constructor(name: string) { super(name); }<br>    move(distanceInMeters = 45) {<br>        console.log(“Galloping…”);<br>        super.move(distanceInMeters);<br>    }<br>}</p>
<p>let sam = new Snake(“Sammy the Python”);<br>let tom: Animal = new Horse(“Tommy the Palomino”);</p>
<p>sam.move();<br>tom.move(34);<br>这个例子展示了一些上面没有提到的特性。 这一次，我们使用 extends关键字创建了 Animal的两个子类： Horse和 Snake。</p>
<p>与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，我们 一定要调用 super()。 这个是TypeScript强制执行的一条重要规则。</p>
<p>这个例子演示了如何在子类里可以重写父类的方法。 Snake类和 Horse类都创建了 move方法，它们重写了从 Animal继承来的 move方法，使得 move方法根据不同的类而具有不同的功能。 注意，即使 tom被声明为 Animal类型，但因为它的值是 Horse，调用 tom.move(34)时，它会调用 Horse里重写的方法：</p>
<p>Slithering…<br>Sammy the Python moved 5m.<br>Galloping…<br>Tommy the Palomino moved 34m.<br>公共，私有与受保护的修饰符<br>默认为 public<br>在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 public来做修饰；例如，C#要求必须明确地使用 public指定成员是可见的。 在TypeScript里，成员都默认为 public。</p>
<p>你也可以明确的将一个成员标记成 public。 我们可以用下面的方式来重写上面的 Animal类：</p>
<p>class Animal {<br>    public name: string;<br>    public constructor(theName: string) { this.name = theName; }<br>    public move(distanceInMeters: number) {<br>        console.log(<code>$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.</code>);<br>    }<br>}</p>
<h3 id="理解-private"><a href="#理解-private" class="headerlink" title="理解 private"></a>理解 private</h3><p>当成员被标记成 private时，它就不能在声明它的类的外部访问。比如：</p>
<p>class Animal {<br>    private name: string;<br>    constructor(theName: string) { this.name = theName; }<br>}</p>
<p>new Animal(“Cat”).name; // 错误: ‘name’ 是私有的.<br>TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。</p>
<p>然而，当我们比较带有 private或 protected成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个 private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected成员也使用这个规则。</p>
<p>下面来看一个例子，更好地说明了这一点：</p>
<p>class Animal {<br>    private name: string;<br>    constructor(theName: string) { this.name = theName; }<br>}</p>
<p>class Rhino extends Animal {<br>    constructor() { super(“Rhino”); }<br>}</p>
<p>class Employee {<br>    private name: string;<br>    constructor(theName: string) { this.name = theName; }<br>}</p>
<p>let animal = new Animal(“Goat”);<br>let rhino = new Rhino();<br>let employee = new Employee(“Bob”);</p>
<p>animal = rhino;<br>animal = employee; // 错误: Animal 与 Employee 不兼容.<br>这个例子中有 Animal和 Rhino两个类， Rhino是 Animal类的子类。 还有一个 Employee类，其类型看上去与 Animal是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 Animal和 Rhino共享了来自 Animal里的私有成员定义 private name: string，因此它们是兼容的。 然而 Employee却不是这样。当把 Employee赋值给 Animal的时候，得到一个错误，说它们的类型不兼容。 尽管 Employee里也有一个私有成员 name，但它明显不是 Animal里面定义的那个。</p>
<h3 id="理解-protected"><a href="#理解-protected" class="headerlink" title="理解 protected"></a>理解 protected</h3><p>protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问。例如：</p>
<p>class Person {<br>    protected name: string;<br>    constructor(name: string) { this.name = name; }<br>}</p>
<p>class Employee extends Person {<br>    private department: string;</p>
<pre><code>constructor(name: string, department: string) &#123;
    super(name)
    this.department = department;
&#125;

public getElevatorPitch() &#123;
    return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`;
&#125;</code></pre>
<p>}</p>
<p>let howard = new Employee(“Howard”, “Sales”);<br>console.log(howard.getElevatorPitch());<br>console.log(howard.name); // 错误</p>
<p>注意，我们不能在 Person类外使用 name，但是我们仍然可以通过 Employee类的实例方法访问，因为 Employee是由 Person派生而来的。</p>
<p>构造函数也可以被标记成 protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如，</p>
<p>class Person {<br>    protected name: string;<br>    protected constructor(theName: string) { this.name = theName; }<br>}</p>
<p>// Employee 能够继承 Person<br>class Employee extends Person {<br>    private department: string;</p>
<pre><code>constructor(name: string, department: string) &#123;
    super(name);
    this.department = department;
&#125;

public getElevatorPitch() &#123;
    return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`;
&#125;</code></pre>
<p>}</p>
<p>let howard = new Employee(“Howard”, “Sales”);<br>let john = new Person(“John”); // 错误: ‘Person’ 的构造函数是被保护的.<br>readonly修饰符<br>你可以使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p>
<p>class Octopus {<br>    readonly name: string;<br>    readonly numberOfLegs: number = 8;<br>    constructor (theName: string) {<br>        this.name = theName;<br>    }<br>}<br>let dad = new Octopus(“Man with the 8 strong legs”);<br>dad.name = “Man with the 3-piece suit”; // 错误! name 是只读的.</p>
<h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>在上面的例子中，我们必须在Octopus类里定义一个只读成员 name和一个参数为 theName的构造函数，并且立刻将 theName的值赋给 name，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 Octopus类的修改版，使用了参数属性：</p>
<p>class Octopus {<br>    readonly numberOfLegs: number = 8;<br>    constructor(readonly name: string) {<br>    }<br>}</p>
<p>注意看我们是如何舍弃了 theName，仅在构造函数里使用 readonly name: string参数来创建和初始化 name成员。 我们把声明和赋值合并至一处。</p>
<p>参数属性通过给构造函数参数前面添加一个访问限定符来声明。 使用 private限定一个参数属性会声明并初始化一个私有成员；对于 public和 protected来说也是一样。</p>
<h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p>
<p>下面来看如何把一个简单的类改写成使用 get和 set。 首先，我们从一个没有使用存取器的例子开始。</p>
<p>class Employee {<br>    fullName: string;<br>}</p>
<p>let employee = new Employee();<br>employee.fullName = “Bob Smith”;<br>if (employee.fullName) {<br>    console.log(employee.fullName);<br>}<br>我们可以随意的设置 fullName，这是非常方便的，但是这也可能会带来麻烦。</p>
<p>下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。 我们把对 fullName的直接访问改成了可以检查密码的 set方法。 我们也加了一个 get方法，让上面的例子仍然可以工作。</p>
<p>let passcode = “secret passcode”;</p>
<p>class Employee {<br>    private _fullName: string;</p>
<pre><code>get fullName(): string &#123;
    return this._fullName;
&#125;

set fullName(newName: string) &#123;
    if (passcode &amp;&amp; passcode == &quot;secret passcode&quot;) &#123;
        this._fullName = newName;
    &#125;
    else &#123;
        console.log(&quot;Error: Unauthorized update of employee!&quot;);
    &#125;
&#125;</code></pre>
<p>}</p>
<p>let employee = new Employee();<br>employee.fullName = “Bob Smith”;<br>if (employee.fullName) {<br>    alert(employee.fullName);<br>}<br>我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。</p>
<p>对于存取器有下面几点需要注意的：</p>
<p>首先，存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有 get不带有 set的存取器自动被推断为 readonly。 这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</p>
<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 static定义 origin，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 origin前面加上类名。 如同在实例属性上使用 this.前缀来访问属性一样，这里我们使用 Grid.来访问静态属性。</p>
<p>class Grid {<br>    static origin = {x: 0, y: 0};<br>    calculateDistanceFromOrigin(point: {x: number; y: number;}) {<br>        let xDist = (point.x - Grid.origin.x);<br>        let yDist = (point.y - Grid.origin.y);<br>        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;<br>    }<br>    constructor (public scale: number) { }<br>}</p>
<p>let grid1 = new Grid(1.0);  // 1x scale<br>let grid2 = new Grid(5.0);  // 5x scale</p>
<p>console.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));<br>console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>
<p>abstract class Animal {<br>    abstract makeSound(): void;<br>    move(): void {<br>        console.log(‘roaming the earch…’);<br>    }<br>}</p>
<p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 abstract关键字并且可以包含访问修饰符。</p>
<p>abstract class Department {</p>
<pre><code>constructor(public name: string) &#123;
&#125;

printName(): void &#123;
    console.log(&#39;Department name: &#39; + this.name);
&#125;

abstract printMeeting(): void; // 必须在派生类中实现</code></pre>
<p>}</p>
<p>class AccountingDepartment extends Department {</p>
<pre><code>constructor() &#123;
    super(&#39;Accounting and Auditing&#39;); // 在派生类的构造函数中必须调用 super()
&#125;

printMeeting(): void &#123;
    console.log(&#39;The Accounting Department meets each Monday at 10am.&#39;);
&#125;

generateReports(): void &#123;
    console.log(&#39;Generating accounting reports...&#39;);
&#125;</code></pre>
<p>}</p>
<p>let department: Department; // 允许创建一个对抽象类型的引用<br>department = new Department(); // 错误: 不能创建一个抽象类的实例<br>department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值<br>department.printName();<br>department.printMeeting();<br>department.generateReports(); // 错误: 方法在声明的抽象类中不存在</p>
<h3 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h3><h4 id="1、构造函数"><a href="#1、构造函数" class="headerlink" title="1、构造函数"></a>1、构造函数</h4><p>当你在TypeScript里声明了一个类的时候，实际上同时声明了很多东西。 首先就是类的 实例的类型。</p>
<p>class Greeter {<br>    greeting: string;<br>    constructor(message: string) {<br>        this.greeting = message;<br>    }<br>    greet() {<br>        return “Hello, “ + this.greeting;<br>    }<br>}</p>
<p>let greeter: Greeter;<br>greeter = new Greeter(“world”);<br>console.log(greeter.greet());</p>
<p>这里，我们写了 let greeter: Greeter，意思是 Greeter类的实例的类型是 Greeter。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。</p>
<p>我们也创建了一个叫做 构造函数的值。 这个函数会在我们使用 new创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：</p>
<p>let Greeter = (function () {<br>    function Greeter(message) {<br>        this.greeting = message;<br>    }<br>    Greeter.prototype.greet = function () {<br>        return “Hello, “ + this.greeting;<br>    };<br>    return Greeter;<br>})();</p>
<p>let greeter;<br>greeter = new Greeter(“world”);<br>console.log(greeter.greet());<br>上面的代码里， let Greeter将被赋值为构造函数。 当我们调用 new并执行了这个函数后，便会得到一个类的实例。 这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有 实例部分与 静态部分这两个部分。</p>
<p>让我们稍微改写一下这个例子，看看它们之间的区别：</p>
<p>class Greeter {<br>    static standardGreeting = “Hello, there”;<br>    greeting: string;<br>    greet() {<br>        if (this.greeting) {<br>            return “Hello, “ + this.greeting;<br>        }<br>        else {<br>            return Greeter.standardGreeting;<br>        }<br>    }<br>}</p>
<p>let greeter1: Greeter;<br>greeter1 = new Greeter();<br>console.log(greeter1.greet());</p>
<p>let greeterMaker: typeof Greeter = Greeter;<br>greeterMaker.standardGreeting = “Hey there!”;</p>
<p>let greeter2: Greeter = new greeterMaker();<br>console.log(greeter2.greet());<br>这个例子里， greeter1与之前看到的一样。 我们实例化 Greeter类，并使用这个对象。 与我们之前看到的一样。</p>
<p>再之后，我们直接使用类。 我们创建了一个叫做 greeterMaker的变量。 这个变量保存了这个类或者说保存了类构造函数。 然后我们使用 typeof Greeter，意思是取Greeter类的类型，而不是实例的类型。 或者更确切的说，”告诉我 Greeter标识符的类型”，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 greeterMaker上使用 new，创建 Greeter的实例。</p>
<h4 id="2、把类当做接口使用"><a href="#2、把类当做接口使用" class="headerlink" title="2、把类当做接口使用"></a>2、把类当做接口使用</h4><p>如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。</p>
<p>class Point {<br>    x: number;<br>    y: number;<br>}</p>
<p>interface Point3d extends Point {<br>    z: number;<br>}</p>
<p>let point3d: Point3d = {x: 1, y: 2, z: 3};</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/31/TypeScript-%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB/" data-id="cl32fwt3v001nlovq3duj4jgo" data-title="TypeScript-接口和类" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TS/" rel="tag">TS</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/11/25/%E6%95%B4%E7%90%86proxy/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          整理ES6语法-Proxy
        
      </div>
    </a>
  
  
    <a href="/2019/03/10/ajax%E3%80%81fetch%E3%80%81axios%E7%9A%84%E5%85%B3%E7%B3%BB/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">ajax、fetch、axios的关系</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/" rel="tag">ES6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TS/" rel="tag">TS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/" rel="tag">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E7%90%86/" rel="tag">原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/" rel="tag">安全问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/tags/JS/" style="font-size: 20px;">JS</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/TS/" style="font-size: 15px;">TS</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/%E5%8E%9F%E7%90%86/" style="font-size: 10px;">原理</a> <a href="/tags/%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/" style="font-size: 10px;">安全问题</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 15px;">面试题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/25/TypeScript-%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/">TypeScript-基础类型和变量声明</a>
          </li>
        
          <li>
            <a href="/2020/02/28/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/">Vue面试题整理</a>
          </li>
        
          <li>
            <a href="/2020/02/27/css%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98/">常考面试题1</a>
          </li>
        
          <li>
            <a href="/2020/01/26/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">深入了解观察者模式</a>
          </li>
        
          <li>
            <a href="/2019/12/19/Vue%E4%B8%AD%E7%9A%84computed%E4%B8%8Ewatch%E7%9A%84%E5%8C%BA%E5%88%AB/">Vue中的computed与watch的区别</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 刘晨曦的个人博客<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>