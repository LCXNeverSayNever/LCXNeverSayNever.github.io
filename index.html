<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>刘晨曦的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="写字楼里写字间，写字间中程序员; 程序人员写程序，又将程序换酒钱，酒醒只在屏前坐，酒醉还来屏下眠: 酒醉酒醒 日复日，屏前屏下年复年; 但愿老死电脑间，不愿鞠躬老板前; 奔驰宝马贵者趣，公交自行程序员; 别人笑我太疯癫，我笑自己命太贱; 但见满街漂亮妹，哪个归得程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="刘晨曦的个人博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="刘晨曦的个人博客">
<meta property="og:description" content="写字楼里写字间，写字间中程序员; 程序人员写程序，又将程序换酒钱，酒醒只在屏前坐，酒醉还来屏下眠: 酒醉酒醒 日复日，屏前屏下年复年; 但愿老死电脑间，不愿鞠躬老板前; 奔驰宝马贵者趣，公交自行程序员; 别人笑我太疯癫，我笑自己命太贱; 但见满街漂亮妹，哪个归得程序员">
<meta property="og:locale">
<meta property="article:author" content="刘晨曦的个人博客">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="刘晨曦的个人博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">刘晨曦的个人博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-TypeScript-基础类型和变量声明" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/25/TypeScript-%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/" class="article-date">
  <time class="dt-published" datetime="2022-03-25T13:18:14.000Z" itemprop="datePublished">2022-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/03/25/TypeScript-%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/">TypeScript-基础类型和变量声明</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。</p>
<p>let isDone: boolean = false;</p>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。</p>
<p>let decLiteral: number = 6;<br>let hexLiteral: number = 0xf00d;<br>let binaryLiteral: number = 0b1010;<br>let octalLiteral: number = 0o744;</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string表示文本数据类型。 和JavaScript一样，可以使用双引号（ “）或单引号（’）表示字符串。</p>
<p>let name: string = “bob”;<br>name = “smith”;<br>你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ `），并且以${ expr }这种形式嵌入表达式</p>
<p>let name: string = <code>Gene</code>;<br>let age: number = 37;<br>let sentence: string = `Hello, my name is ${ name }.</p>
<p>I’ll be ${ age + 1 } years old next month.`;<br>这与下面定义sentence的方式效果相同：</p>
<p>let sentence: string = “Hello, my name is “ + name + “.\n\n” +<br>    “I’ll be “ + (age + 1) + “ years old next month.”;</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组：</p>
<p>let list: number[] = [1, 2, 3];<br>第二种方式是使用数组泛型，Array&lt;元素类型&gt;：</p>
<p>let list: Array<number> = [1, 2, 3];<br>元组 Tuple<br>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。</number></p>
<p>// Declare a tuple type<br>let x: [string, number];<br>// Initialize it<br>x = [‘hello’, 10]; // OK<br>// Initialize it incorrectly<br>x = [10, ‘hello’]; // Error<br>当访问一个已知索引的元素，会得到正确的类型：</p>
<p>console.log(x[0].substr(1)); // OK<br>console.log(x[1].substr(1)); // Error, ‘number’ does not have ‘substr’<br>当访问一个越界的元素，会使用联合类型替代：</p>
<p>x[3] = ‘world’; // OK, 字符串可以赋值给(string | number)类型</p>
<p>console.log(x[5].toString()); // OK, ‘string’ 和 ‘number’ 都有 toString</p>
<p>x[6] = true; // Error, 布尔不是(string | number)类型<br>联合类型是高级主题，我们会在以后的章节里讨论它。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>
<p>enum Color {Red, Green, Blue}<br>let c: Color = Color.Green;<br>默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：</p>
<p>enum Color {Red = 1, Green, Blue}<br>let c: Color = Color.Green;<br>或者，全部都采用手动赋值：</p>
<p>enum Color {Red = 1, Green = 2, Blue = 4}<br>let c: Color = Color.Green;<br>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p>
<p>enum Color {Red = 1, Green, Blue}<br>let colorName: string = Color[2];</p>
<p>console.log(colorName);  // 显示’Green’因为上面代码里它的值是2</p>
<h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量：</p>
<p>let notSure: any = 4;<br>notSure = “maybe a string instead”;<br>notSure = false; // okay, definitely a boolean<br>在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 Object有相似的作用，就像它在其它语言中那样。 但是 Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：</p>
<p>let notSure: any = 4;<br>notSure.ifItExists(); // okay, ifItExists might exist at runtime<br>notSure.toFixed(); // okay, toFixed exists (but the compiler doesn’t check)</p>
<p>let prettySure: Object = 4;<br>prettySure.toFixed(); // Error: Property ‘toFixed’ doesn’t exist on type ‘Object’.<br>当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>
<p>let list: any[] = [1, true, “free”];</p>
<p>list[1] = 100;</p>
<h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><p>某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p>
<p>function warnUser(): void {<br>    console.log(“This is my warning message”);<br>}<br>声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：</p>
<p>let unusable: void = undefined;<br>Null 和 Undefined<br>TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大：</p>
<p>// Not much else we can assign to these variables!<br>let u: undefined = undefined;<br>let n: null = null;<br>默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。</p>
<p>然而，当你指定了–strictNullChecks标记，null和undefined只能赋值给void和它们各自。 这能避免 很多常见的问题。 也许在某处你想传入一个 string或null或undefined，你可以使用联合类型string | null | undefined。 再次说明，稍后我们会介绍联合类型。</p>
<h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><p>never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。</p>
<p>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。</p>
<p>下面是一些返回never类型的函数：</p>
<p>// 返回never的函数必须存在无法达到的终点<br>function error(message: string): never {<br>    throw new Error(message);<br>}</p>
<p>// 推断的返回值类型为never<br>function fail() {<br>    return error(“Something failed”);<br>}</p>
<p>// 返回never的函数必须存在无法达到的终点<br>function infiniteLoop(): never {<br>    while (true) {<br>    }<br>}</p>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。</p>
<p>使用object类型，就可以更好的表示像Object.create这样的API。例如：</p>
<p>declare function create(o: object | null): void;</p>
<p>create({ prop: 0 }); // OK<br>create(null); // OK</p>
<p>create(42); // Error<br>create(“string”); // Error<br>create(false); // Error<br>create(undefined); // Error</p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>
<p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。</p>
<p>类型断言有两种形式。 其一是“尖括号”语法：</p>
<p>let someValue: any = “this is a string”;</p>
<p>let strLength: number = (<string>someValue).length;<br>另一个为as语法：</string></p>
<p>let someValue: any = “this is a string”;</p>
<p>let strLength: number = (someValue as string).length;<br>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。</p>
<h3 id="关于let"><a href="#关于let" class="headerlink" title="关于let"></a>关于let</h3><p>你可能已经注意到了，我们使用let关键字来代替大家所熟悉的JavaScript关键字var。 let关键字是JavaScript的一个新概念，TypeScript实现了它。 我们会在以后详细介绍它，很多常见的问题都可以通过使用 let来解决，所以尽可能地使用let来代替var吧。</p>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><h3 id="var-声明"><a href="#var-声明" class="headerlink" title="var 声明"></a>var 声明</h3><p>一直以来我们都是通过var关键字定义JavaScript变量。</p>
<p>var a = 10;<br>大家都能理解，这里定义了一个名为a值为10的变量。</p>
<p>我们也可以在函数内部定义变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">    var message &#x3D; &quot;Hello, world!&quot;;</span><br><span class="line"></span><br><span class="line">    return message;</span><br><span class="line">&#125;</span><br><span class="line">并且我们也可以在其它函数内部访问相同的变量。</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">    var a &#x3D; 10;</span><br><span class="line">    return function g() &#123;</span><br><span class="line">        var b &#x3D; a + 1;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g &#x3D; f();</span><br><span class="line">g(); &#x2F;&#x2F; returns 11;</span><br><span class="line">上面的例子里，g可以获取到f函数里定义的a变量。 每当 g被调用时，它都可以访问到f里的a变量。 即使当 g在f已经执行完后才被调用，它仍然可以访问及修改a。</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">    var a &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    a &#x3D; 2;</span><br><span class="line">    var b &#x3D; g();</span><br><span class="line">    a &#x3D; 3;</span><br><span class="line"></span><br><span class="line">    return b;</span><br><span class="line"></span><br><span class="line">    function g() &#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); &#x2F;&#x2F; returns 2</span><br><span class="line">作用域规则</span><br><span class="line">对于熟悉其它语言的人来说，var声明有些奇怪的作用域规则。 看下面的例子：</span><br><span class="line"></span><br><span class="line">function f(shouldInitialize: boolean) &#123;</span><br><span class="line">    if (shouldInitialize) &#123;</span><br><span class="line">        var x &#x3D; 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(true);  &#x2F;&#x2F; returns &#39;10&#39;</span><br><span class="line">f(false); &#x2F;&#x2F; returns &#39;undefined&#39;</span><br><span class="line">有些读者可能要多看几遍这个例子。 变量 x是定义在*if语句里面*，但是我们却可以在语句的外面访问它。 这是因为 var声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为* var作用域或函数作用域*。 函数参数也使用函数作用域。</span><br><span class="line"></span><br><span class="line">这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：</span><br><span class="line"></span><br><span class="line">function sumMatrix(matrix: number[][]) &#123;</span><br><span class="line">    var sum &#x3D; 0;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        var currentRow &#x3D; matrix[i];</span><br><span class="line">        for (var i &#x3D; 0; i &lt; currentRow.length; i++) &#123;</span><br><span class="line">            sum +&#x3D; currentRow[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">这里很容易看出一些问题，里层的for循环会覆盖变量i，因为所有i都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。</span><br><span class="line"></span><br><span class="line">捕获变量怪异之处</span><br><span class="line">快速的猜一下下面的代码会返回什么：</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">    setTimeout(function() &#123; console.log(i); &#125;, 100 * i);</span><br><span class="line">&#125;</span><br><span class="line">介绍一下，setTimeout会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。</span><br><span class="line"></span><br><span class="line">好吧，看一下结果：</span><br><span class="line"></span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">很多JavaScript程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样：</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">还记得我们上面提到的捕获变量吗？</span><br><span class="line"></span><br><span class="line">我们传给setTimeout的每一个函数表达式实际上都引用了相同作用域里的同一个i。</span><br><span class="line"></span><br><span class="line">让我们花点时间思考一下这是为什么。 setTimeout在若干毫秒后执行一个函数，并且是在for循环结束后。 for循环结束后，i的值为10。 所以当函数被调用的时候，它会打印出 10！</span><br><span class="line"></span><br><span class="line">一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时i的值：</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; capture the current state of &#39;i&#39;</span><br><span class="line">    &#x2F;&#x2F; by invoking a function with its current value</span><br><span class="line">    (function(i) &#123;</span><br><span class="line">        setTimeout(function() &#123; console.log(i); &#125;, 100 * i);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">这种奇怪的形式我们已经司空见惯了。 参数 i会覆盖for循环里的i，但是因为我们起了同样的名字，所以我们不用怎么改for循环体里的代码。</span><br></pre></td></tr></table></figure>
<h3 id="let-声明"><a href="#let-声明" class="headerlink" title="let 声明"></a>let 声明</h3><p>现在你已经知道了var存在一些问题，这恰好说明了为什么用let语句来声明变量。 除了名字不同外， let与var的写法一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">let hello &#x3D; &quot;Hello!&quot;;</span><br><span class="line">主要的区别不在语法上，而是语义，我们接下来会深入研究。</span><br><span class="line"></span><br><span class="line">块作用域</span><br><span class="line">当用let声明一个变量，它使用的是词法作用域或块作用域。 不同于使用 var声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或for循环之外是不能访问的。</span><br><span class="line"></span><br><span class="line">function f(input: boolean) &#123;</span><br><span class="line">    let a &#x3D; 100;</span><br><span class="line"></span><br><span class="line">    if (input) &#123;</span><br><span class="line">        &#x2F;&#x2F; Still okay to reference &#39;a&#39;</span><br><span class="line">        let b &#x3D; a + 1;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Error: &#39;b&#39; doesn&#39;t exist here</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line">这里我们定义了2个变量a和b。 a的作用域是f函数体内，而b的作用域是if语句块里。</span><br><span class="line"></span><br><span class="line">在catch语句里声明的变量也具有同样的作用域规则。</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    throw &quot;oh no!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">catch (e) &#123;</span><br><span class="line">    console.log(&quot;Oh well.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Error: &#39;e&#39; doesn&#39;t exist here</span><br><span class="line">console.log(e);</span><br><span class="line">拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于 暂时性死区。 它只是用来说明我们不能在 let语句之前访问它们，幸运的是TypeScript可以告诉我们这些信息。</span><br><span class="line"></span><br><span class="line">a++; &#x2F;&#x2F; illegal to use &#39;a&#39; before it&#39;s declared;</span><br><span class="line">let a;</span><br><span class="line">注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为ES2015，现代的运行时会抛出一个错误；然而，现今TypeScript是不会报错的。</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    &#x2F;&#x2F; okay to capture &#39;a&#39;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不能在&#39;a&#39;被声明前调用&#39;foo&#39;</span><br><span class="line">&#x2F;&#x2F; 运行时应该抛出错误</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">let a;</span><br><span class="line">关于暂时性死区的更多信息，查看这里Mozilla Developer Network.</span><br><span class="line"></span><br><span class="line">重定义及屏蔽</span><br><span class="line">我们提过使用var声明时，它不在乎你声明多少次；你只会得到1个。</span><br><span class="line"></span><br><span class="line">function f(x) &#123;</span><br><span class="line">    var x;</span><br><span class="line">    var x;</span><br><span class="line"></span><br><span class="line">    if (true) &#123;</span><br><span class="line">        var x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">在上面的例子里，所有x的声明实际上都引用一个相同的x，并且这是完全有效的代码。 这经常会成为bug的来源。 好的是， let声明就不会这么宽松了。</span><br><span class="line"></span><br><span class="line">let x &#x3D; 10;</span><br><span class="line">let x &#x3D; 20; &#x2F;&#x2F; 错误，不能在1个作用域里多次声明&#96;x&#96;</span><br><span class="line">并不是要求两个均是块级作用域的声明TypeScript才会给出一个错误的警告。</span><br><span class="line"></span><br><span class="line">function f(x) &#123;</span><br><span class="line">    let x &#x3D; 100; &#x2F;&#x2F; error: interferes with parameter declaration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function g() &#123;</span><br><span class="line">    let x &#x3D; 100;</span><br><span class="line">    var x &#x3D; 100; &#x2F;&#x2F; error: can&#39;t have both declarations of &#39;x&#39;</span><br><span class="line">&#125;</span><br><span class="line">并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。</span><br><span class="line"></span><br><span class="line">function f(condition, x) &#123;</span><br><span class="line">    if (condition) &#123;</span><br><span class="line">        let x &#x3D; 100;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(false, 0); &#x2F;&#x2F; returns 0</span><br><span class="line">f(true, 0);  &#x2F;&#x2F; returns 100</span><br><span class="line">在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 let重写之前的sumMatrix函数。</span><br><span class="line"></span><br><span class="line">function sumMatrix(matrix: number[][]) &#123;</span><br><span class="line">    let sum &#x3D; 0;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        var currentRow &#x3D; matrix[i];</span><br><span class="line">        for (let i &#x3D; 0; i &lt; currentRow.length; i++) &#123;</span><br><span class="line">            sum +&#x3D; currentRow[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">这个版本的循环能得到正确的结果，因为内层循环的i可以屏蔽掉外层循环的i。</span><br><span class="line"></span><br><span class="line">通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好打算一下。</span><br><span class="line"></span><br><span class="line">块级作用域变量的获取</span><br><span class="line">在我们最初谈及获取用var声明的变量时，我们简略地探究了一下在获取到了变量之后它的行为是怎样的。 直观地讲，每次进入一个作用域时，它创建了一个变量的 环境。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。</span><br><span class="line"></span><br><span class="line">function theCityThatAlwaysSleeps() &#123;</span><br><span class="line">    let getCity;</span><br><span class="line"></span><br><span class="line">    if (true) &#123;</span><br><span class="line">        let city &#x3D; &quot;Seattle&quot;;</span><br><span class="line">        getCity &#x3D; function() &#123;</span><br><span class="line">            return city;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return getCity();</span><br><span class="line">&#125;</span><br><span class="line">因为我们已经在city的环境里获取到了city，所以就算if语句执行结束后我们仍然可以访问它。</span><br><span class="line"></span><br><span class="line">回想一下前面setTimeout的例子，我们最后需要使用立即执行的函数表达式来获取每次for循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在TypeScript里这样做了。</span><br><span class="line"></span><br><span class="line">当let声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 每次迭代都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在 setTimeout例子里我们仅使用let声明就可以了。</span><br><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; 10 ; i++) &#123;</span><br><span class="line">    setTimeout(function() &#123;console.log(i); &#125;, 100 * i);</span><br><span class="line">&#125;</span><br><span class="line">会输出与预料一致的结果：</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<h3 id="const-声明"><a href="#const-声明" class="headerlink" title="const 声明"></a>const 声明</h3><p>const 声明是声明变量的另一种方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const numLivesForCat &#x3D; 9;</span><br><span class="line">它们与let声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 let相同的作用域规则，但是不能对它们重新赋值。</span><br><span class="line"></span><br><span class="line">这很好理解，它们引用的值是不可变的。</span><br><span class="line"></span><br><span class="line">const numLivesForCat &#x3D; 9;</span><br><span class="line">const kitty &#x3D; &#123;</span><br><span class="line">    name: &quot;Aurora&quot;,</span><br><span class="line">    numLives: numLivesForCat,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Error</span><br><span class="line">kitty &#x3D; &#123;</span><br><span class="line">    name: &quot;Danielle&quot;,</span><br><span class="line">    numLives: numLivesForCat</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; all &quot;okay&quot;</span><br><span class="line">kitty.name &#x3D; &quot;Rory&quot;;</span><br><span class="line">kitty.name &#x3D; &quot;Kitty&quot;;</span><br><span class="line">kitty.name &#x3D; &quot;Cat&quot;;</span><br><span class="line">kitty.numLives--;</span><br><span class="line">除非你使用特殊的方法去避免，实际上const变量的内部状态是可修改的。 幸运的是，TypeScript允许你将对象的成员设置成只读的。 接口一章有详细说明。</span><br></pre></td></tr></table></figure>
<h3 id="let-vs-const"><a href="#let-vs-const" class="headerlink" title="let vs. const"></a>let vs. const</h3><p>现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。 与大多数泛泛的问题一样，答案是：依情况而定。</p>
<p>使用最小特权原则，所有变量除了你计划去修改的都应该使用const。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用 const也可以让我们更容易的推测数据的流动。</p>
<p>跟据你的自己判断，如果合适的话，与团队成员商议一下。</p>
<p>这个手册大部分地方都使用了let声明。</p>
<h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p>Another TypeScript已经可以解析其它 ECMAScript 2015 特性了。 完整列表请参见 the article on the Mozilla Developer Network。 本章，我们将给出一个简短的概述。</p>
<h4 id="解构数组"><a href="#解构数组" class="headerlink" title="解构数组"></a>解构数组</h4><p>最简单的解构莫过于数组的解构赋值了：</p>
<p>let input = [1, 2];<br>let [first, second] = input;<br>console.log(first); // outputs 1<br>console.log(second); // outputs 2<br>这创建了2个命名变量 first 和 second。 相当于使用了索引，但更为方便：</p>
<p>first = input[0];<br>second = input[1];<br>解构作用于已声明的变量会更好：</p>
<p>// swap variables<br>[first, second] = [second, first];</p>
<h4 id="作用于函数参数："><a href="#作用于函数参数：" class="headerlink" title="作用于函数参数："></a>作用于函数参数：</h4><p>function f([first, second]: [number, number]) {<br>    console.log(first);<br>    console.log(second);<br>}<br>f(input);<br>你可以在数组里使用…语法创建剩余变量：</p>
<p>let [first, …rest] = [1, 2, 3, 4];<br>console.log(first); // outputs 1<br>console.log(rest); // outputs [ 2, 3, 4 ]<br>当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：</p>
<p>let [first] = [1, 2, 3, 4];<br>console.log(first); // outputs 1<br>或其它元素：</p>
<p>let [, second, , fourth] = [1, 2, 3, 4];</p>
<h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><p>你也可以解构对象：</p>
<p>let o = {<br>    a: “foo”,<br>    b: 12,<br>    c: “bar”<br>};<br>let { a, b } = o;<br>这通过 o.a and o.b 创建了 a 和 b 。 注意，如果你不需要 c 你可以忽略它。</p>
<p>就像数组解构，你可以用没有声明的赋值：</p>
<p>({ a, b } = { a: “baz”, b: 101 });<br>注意，我们需要用括号将它括起来，因为Javascript通常会将以 { 起始的语句解析为一个块。</p>
<p>你可以在对象里使用…语法创建剩余变量：</p>
<p>let { a, …passthrough } = o;<br>let total = passthrough.b + passthrough.c.length;</p>
<h4 id="属性重命名"><a href="#属性重命名" class="headerlink" title="属性重命名"></a>属性重命名</h4><p>你也可以给属性以不同的名字：</p>
<p>let { a: newName1, b: newName2 } = o;<br>这里的语法开始变得混乱。 你可以将 a: newName1 读做 “a 作为 newName1”。 方向是从左到右，好像你写成了以下样子：</p>
<p>let newName1 = o.a;<br>let newName2 = o.b;<br>令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。</p>
<p>let {a, b}: {a: string, b: number} = o;</p>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>默认值可以让你在属性为 undefined 时使用缺省值：</p>
<p>function keepWholeObject(wholeObject: { a: string, b?: number }) {<br>    let { a, b = 1001 } = wholeObject;<br>}<br>现在，即使 b 为 undefined ， keepWholeObject 函数的变量 wholeObject 的属性 a 和 b 都会有值。</p>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>解构也能用于函数声明。 看以下简单的情况：</p>
<p>type C = { a: string, b?: number }<br>function f({ a, b }: C): void {<br>    // …<br>}<br>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。</p>
<p>function f({ a=””, b=0 } = {}): void {<br>    // …<br>}<br>f();<br>上面的代码是一个类型推断的例子，将在本手册后文介绍。</p>
<p>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：</p>
<p>function f({ a, b = 0 } = { a: “” }): void {<br>    // …<br>}<br>f({ a: “yes” }); // ok, default b = 0<br>f(); // ok, default to {a: “”}, which then defaults b = 0<br>f({}); // error, ‘a’ is required if you supply an argument<br>要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。</p>
<h4 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h4><p>展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：</p>
<p>let first = [1, 2];<br>let second = [3, 4];<br>let bothPlus = [0, …first, …second, 5];<br>这会令bothPlus的值为[0, 1, 2, 3, 4, 5]。 展开操作创建了 first和second的一份浅拷贝。 它们不会被展开操作所改变。</p>
<p>你还可以展开对象：</p>
<p>let defaults = { food: “spicy”, price: “$$”, ambiance: “noisy” };<br>let search = { …defaults, food: “rich” };<br>search的值为{ food: “rich”, price: “$$”, ambiance: “noisy” }。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：</p>
<p>let defaults = { food: “spicy”, price: “$$”, ambiance: “noisy” };<br>let search = { food: “rich”, …defaults };<br>那么，defaults里的food属性会重写food: “rich”，在这里这并不是我们想要的结果。</p>
<p>对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法：</p>
<p>class C {<br>  p = 12;<br>  m() {<br>  }<br>}<br>let c = new C();<br>let clone = { …c };<br>clone.p; // ok<br>clone.m(); // error!<br>其次，TypeScript编译器不允许展开泛型函数上的类型参数。 这个特性会在TypeScript的未来版本中考虑实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/25/TypeScript-%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/" data-id="cl32gzike001ihwvqg5n1gien" data-title="TypeScript-基础类型和变量声明" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TS/" rel="tag">TS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Vue面试题整理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/28/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2020-02-28T10:50:18.000Z" itemprop="datePublished">2020-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/28/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/">Vue面试题整理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="vue-指令"><a href="#vue-指令" class="headerlink" title="vue 指令"></a>vue 指令</h2><ul>
<li>解释：指令 (Directives) 是带有 v- 前缀的特殊属性。</li>
<li>作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</li>
</ul>
<hr>
<h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><ul>
<li>解释：更新元素的 textContent</li>
</ul>
<h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><ul>
<li>解释：更新元素的 innerHTML</li>
</ul>
<h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><ul>
<li>作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</li>
<li>语法：v-bind:title=”msg”</li>
<li>简写：:title=”msg”</li>
</ul>
<h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><ul>
<li>作用：绑定事件</li>
<li>语法：v-on:click=”say” or v-on:click=”say(‘参数’, $event)”</li>
<li>简写：@click=”say”</li>
<li>说明：绑定的事件从 methods 中获取</li>
</ul>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><ul>
<li>作用：在表单元素上创建双向数据绑定</li>
<li>说明：监听用户的输入事件以更新数据</li>
</ul>
<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><ul>
<li>作用：基于源数据多次渲染元素或模板块</li>
</ul>
<h3 id="v-if-和-v-show"><a href="#v-if-和-v-show" class="headerlink" title="v-if 和 v-show"></a>v-if 和 v-show</h3><ul>
<li>条件渲染</li>
<li>v-if：根据表达式的值的真假条件，销毁或重建元素</li>
<li>v-show：根据表达式之真假值，切换元素的 display CSS 属性</li>
</ul>
<h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h3><ul>
<li>限制：前一兄弟元素必须有 v-if 或 v-else-if。</li>
<li>用法：为 v-if 或者 v-else-if 添加“else 块”。</li>
</ul>
<h3 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h3><ul>
<li>限制：前一兄弟元素必须有 v-if 或 v-else-if。</li>
<li>表示 v-if 的“else if 块”。可以链式调用。</li>
</ul>
<h3 id="v-slot"><a href="#v-slot" class="headerlink" title="v-slot"></a>v-slot</h3><ul>
<li>用法：提供具名插槽或需要接收 prop 的插槽。</li>
<li>限用于：template 标签当中，组件 (对于一个单独的带 prop 的默认插槽)</li>
<li>参数：插槽名 (可选，默认值是 default)</li>
</ul>
<h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><ul>
<li>.stop 阻止冒泡，调用 event.stopPropagation()</li>
<li>.prevent 阻止默认事件，调用 event.preventDefault()</li>
<li>.capture 添加事件侦听器时使用事件捕获模式</li>
<li>.self 只当事件在该元素本身（比如不是子元素）触发时触发回调</li>
<li>.once 事件只触发一次</li>
</ul>
<h3 id="样式处理-class-和-style"><a href="#样式处理-class-和-style" class="headerlink" title="样式处理 -class 和 style"></a>样式处理 -class 和 style</h3><ul>
<li>说明：这两个都是 HTML 元素的属性，使用 v-bind，只需要通过表达式计算出字符串结果即可</li>
<li>表达式的类型：字符串、数组、对象</li>
</ul>
<h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><ul>
<li>用法：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</li>
</ul>
<h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><ul>
<li>用法：这个指令保持在元素上直到关联实例结束编译。和 CSS 规则一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</li>
</ul>
<h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><ul>
<li>用法：只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</li>
</ul>
<h2 id="Vue-插槽（slot）"><a href="#Vue-插槽（slot）" class="headerlink" title="Vue 插槽（slot）"></a>Vue 插槽（slot）</h2><ul>
<li>概念：是 Vue 提出来的一个概念，正如名字一样，插槽用于决定将所携带的内容，插入到指定的某个位置，从而使模板分块，具有模块化的特质和更大的重用性。</li>
<li>作用：为了让组件更加具有扩展性。抽取共性，保留不同为插槽，让其他组件可以传递自己想展示的标签到预留插槽。</li>
</ul>
<h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><ul>
<li>在组件中定义一个slot标签即可</li>
<li>如果插槽内具有共性的东西较多，可在插槽内设置默认值，当没有在插槽传入值时显示默认值</li>
<li>如果有多个值，同时放入到组件中进行替换时，一起作为替换元素</li>
</ul>
<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><blockquote>
<p>通常情况下，一个页面设计非常复杂，需要在一个页面的不同位置放入不同的插槽内容。那么在这种情况下，我们就需要给插槽 <slot> 指定一个具体的名称 name，使其具有具体匹配的特性，在 Vue 中把这种具有具体名称 name 的插槽.</slot></p>
</blockquote>
<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><blockquote>
<p>通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强程序的可靠性，减少名字冲突。</p>
</blockquote>
<h2 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>在 Vue 从创建实例到最终完全消亡的过程中，会执行一系列的方法，用于对应当前 Vue 的状态，这些方法我们叫它：生命周期钩子！</p>
</blockquote>
<h3 id="8-个生命周期函数"><a href="#8-个生命周期函数" class="headerlink" title="8 个生命周期函数"></a>8 个生命周期函数</h3><ol>
<li>beforeCreate：在实例初始化之后。</li>
<li>created：在实例创建完成后被立即调用。</li>
<li>beforeMount：在挂载开始之前被调用，相关的 render 函数首次被调用。</li>
<li>mounted：el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。</li>
<li>beforeUpdate：数据更新时调用。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</li>
<li>updated：数据更新之后调用。</li>
<li>beforeDestroy：实例销毁之前调用，在这一步，实例仍然完全可用。</li>
<li>destroyed：Vue 实例销毁后调用。</li>
</ol>
<h3 id="3-个关于-vue-组件的生命周期钩子"><a href="#3-个关于-vue-组件的生命周期钩子" class="headerlink" title="3 个关于 vue 组件的生命周期钩子"></a>3 个关于 vue 组件的生命周期钩子</h3><ol>
<li>activated：keep-alive 组件激活时调用</li>
<li>deactivated：keep-alive 组件停用时调用</li>
<li>errorCaptured：当捕获一个来自子孙组件的错误时被调用。<br>此钩子会收到 3 个参数：<ul>
<li>错误对象</li>
<li>发生错误的组件实例</li>
<li>一个包含错误来源信息的字符串<br>返回值：此钩子可以返回 false 以阻止该错误继续向上传播。</li>
</ul>
</li>
</ol>
<h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><ul>
<li>概念：keep-alive 是一个内置抽象组件（它自身不会渲染一个 DOM 元素，也不会出现在父组件链中，abstract: true 属性值决定）。</li>
<li>作用：包裹动态组件时，会缓存不活动的组件实例。而不是销毁它们。 其主要用于保留组件状态（保留在内存中），避免重新渲染。</li>
</ul>
<hr>
<h3 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h3><ol>
<li>从列表进入详情页面，再回到列表页面，不需要刷新列表页面</li>
<li>填写表单，进入下一步，返回上一步数据不会清空</li>
<li>长列表内容</li>
</ol>
<h3 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h3><p>有三个属性 Props：</p>
<ul>
<li>include 字符串或正则表达式。只有名称匹配的组件会被缓存。</li>
<li>exclude 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li>
<li>max 最多可以缓存多少组件实例。</li>
</ul>
<h3 id="常见面试题："><a href="#常见面试题：" class="headerlink" title="常见面试题："></a>常见面试题：</h3><p>本文引自：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6921158170224099335#heading-4">https://juejin.cn/post/6921158170224099335#heading-4</a></p>
<h2 id="谈一谈-Vuex"><a href="#谈一谈-Vuex" class="headerlink" title="谈一谈 Vuex"></a>谈一谈 Vuex</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式,可以帮助我们管理共享状态。<br>Vuex 是实现组件全局状态(数据) 管理的一种机制，可以方便的实现组件之间数据的共享。</p>
<h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><p>Vuex 的组成部分如下：</p>
<ol>
<li>state：State 提供唯一的公共数据源，所有共享的数据都要统一放到 Store 的 State 中进行存储</li>
<li>mutations：用于变更 Store 中的数据</li>
</ol>
<ul>
<li>不能直接改变 store 仓库中的状态</li>
<li>改变 store 中的状态唯一途径就是显示地提交 mutation。</li>
<li>这样使得我们可以方便地跟踪每一个状态地变化，从而让我们能够实现一些工具帮助我们更好地了解我们地应用。</li>
</ul>
<ol start="3">
<li>actions：用于处理异步任务。如果通过异步操作变更数据，必须通过 Action，而不能使用 Mutation，但是在 Action 中还是要通过触发 Mutation 的方式间接变更数据。</li>
<li>getters：用于对 Store 中的数据进行加工处理形成新的数据。</li>
</ol>
<ul>
<li>getters 可以对 Store 中已有的数据加工处理之后形成新的数据,类似 Vue 的计算属性</li>
<li>Store 中数据发生变化，Getter 的数据也会跟着变化</li>
</ul>
<ol start="5">
<li>modules：拆分，方便多人协同开发。</li>
</ol>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>能够在 vuex 中集中管理共享的数据，易于开发和后期维护</li>
<li>能够高效地实现组件之间的数据共享，提高开发效率</li>
<li>存储在 vuex 中的数据都是响应式的，能够实时保持数据与页面的同步。</li>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>一般情况下，只有组件之间共享的数据，才有必要存储到 vuex 中；对于组件中的私有数据，依旧存储在组件自身的 data 中即可。</p>
<h2 id="Vue-异步组件"><a href="#Vue-异步组件" class="headerlink" title="Vue 异步组件"></a>Vue 异步组件</h2><h3 id="普通函数异步组件"><a href="#普通函数异步组件" class="headerlink" title="普通函数异步组件"></a>普通函数异步组件</h3><h3 id="Promise异步组件"><a href="#Promise异步组件" class="headerlink" title="Promise异步组件"></a>Promise异步组件</h3><h3 id="高级异步组件"><a href="#高级异步组件" class="headerlink" title="高级异步组件"></a>高级异步组件</h3><h2 id="Vue-事件总线（EventBus）"><a href="#Vue-事件总线（EventBus）" class="headerlink" title="Vue 事件总线（EventBus）"></a>Vue 事件总线（EventBus）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>EventBus 又称为事件总线。在 Vue 中可以使用 EventBus 来作为沟通桥梁的概念，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件。</p>
<h3 id="使用以及注意事项"><a href="#使用以及注意事项" class="headerlink" title="使用以及注意事项"></a>使用以及注意事项</h3><p>新创建一个 event-bus.js 文件;<br>首先需要创建事件总线并将其导出，以便其它组件可以使用或者监听它。<br>然后假设你有两个 Vue 组件 A 和 B,A 组件需要通知 B 组件。<br>最后分别在两个组件中引入 EventBus<br><strong>发送：</strong> A 组件通过 EventBus.$emit(事件名,payload)发送；<br><strong>接收：</strong> B 组件通过 EventBus.$on(事件名,payload)接收；<br><strong>移除：</strong></p>
<ol>
<li>通过 EventBus.$off(事件名)来移除应用内所有对此某个事件的监听</li>
<li>直接调用 EventBus.$off() 来移除所有事件频道，不需要添加任何参数 。</li>
</ol>
<p><span style="color:red;font-size:16px;">注意事项：</span></p>
<ol>
<li>如果你在某一个组件刷新了之后，与之相关的 EventBus 会被移除，这样就导致业务走不下去。</li>
<li>如果业务有反复操作的组件，EventBus 在监听的时候就会触发很多次，也是一个非常大的隐患。</li>
</ol>
<p><span style="color:blue;font-size:16px;">解决方法：</span></p>
<p><strong>在 vue 组件销毁时，同时移除 EventBus 事件监听。</strong></p>
<h2 id="Vuex-与全局对象的区别"><a href="#Vuex-与全局对象的区别" class="headerlink" title="Vuex 与全局对象的区别"></a>Vuex 与全局对象的区别</h2><h2 id="Vue-router-相关问题"><a href="#Vue-router-相关问题" class="headerlink" title="Vue-router 相关问题"></a>Vue-router 相关问题</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ol>
<li>vue-router 是 WebApp 的链接路径管理系统。</li>
<li>vue-router 是 Vue.js 官方的路由插件，它和 vue.js 是深度集成的，适合用于构建单页面应用。</li>
</ol>
<h3 id="它与传统的页面跳转的区别"><a href="#它与传统的页面跳转的区别" class="headerlink" title="它与传统的页面跳转的区别"></a>它与传统的页面跳转的区别</h3><ol>
<li>vue 的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来（一个 url 地址对应着一个组件）。</li>
<li>传统的页面应用，是用一些超链接来实现页面切换和跳转的。</li>
</ol>
<blockquote>
<p>换而言之在 vue-router 单页面应用中，则是路径之间的切换，也就是组件的切换。路由模块的本质 就是建立起 url 和页面之间的映射关系。</p>
</blockquote>
<h3 id="为什么使用-vue-router"><a href="#为什么使用-vue-router" class="headerlink" title="为什么使用 vue-router"></a>为什么使用 vue-router</h3><blockquote>
<p>我们为什么不能使用 a 标签代替，这是因为用 Vue 做的都是单页面应用（当你的项目准备打包时，运行 npm run build 时，就会生成 dist 文件夹，这里面只有静态资源和一个 index.html 页面，在没有后端服务的支持下，浏览器无法找到对应的 url 路径的），所以你写的标签是不起作用的，你必须使用 vue-router 来进行管理。</p>
</blockquote>
<ul>
<li>vue-router 的功能</li>
</ul>
<ol>
<li>嵌套的路由/视图表</li>
<li>模块化的、基于组件的路由配置</li>
<li>路由参数、查询、通配符</li>
<li>基于 Vue.js 过渡系统的视图过渡效果</li>
<li>HTML5 history 模式或 hash 模式，在 IE9 中自动降级。</li>
</ol>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>单页面应用(SPA)的核心之一是:</p>
<ol>
<li>更新视图而不重新请求页面</li>
<li>vue-router 在实现单页面前端路由时，提供了三种方式： Hash 模式;History 模式;根据 mode 参数以及运行环境决定采用哪一种方式。</li>
</ol>
<hr>
<h5 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h5><ul>
<li>vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</li>
<li>hash 模式的原理是 onhashchange 事件(监测 hash 值变化)，可以在 window 对象上监听这个事件。</li>
</ul>
<h5 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h5><blockquote>
<p>html5 history interface 中新增的了 pushState() 和 replaceState()方法这两个方法应用于浏览器记录栈，在当前已有的 back、forward、go 基础之上，它们提供了对历史记录修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。同时还有 popstate 事件。通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。</p>
</blockquote>
<h5 id="history-模式，页面返回-404"><a href="#history-模式，页面返回-404" class="headerlink" title="history 模式，页面返回 404"></a>history 模式，页面返回 404</h5><ul>
<li><p>问题原因：因为 history 模式是 html5 新增特性，它的功能只是来改变浏览器地址栏里的路径，并没有发起 http 请求，但是当我直接在浏览器里输入这个地址的时候，就一定要对服务器发起 http 请求，但是这个目标在服务器上又不存在， 所以会返回 404。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。</p>
</li>
<li><p>具体做法：要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/28/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" data-id="cl32gzijx000chwvqfngg55oj" data-title="Vue面试题整理" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-css常考面试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/27/css%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2020-02-27T11:49:32.000Z" itemprop="datePublished">2020-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/27/css%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98/">常考面试题1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="dispaly-none-与-visibility-hidden-的区别"><a href="#dispaly-none-与-visibility-hidden-的区别" class="headerlink" title="dispaly:none;与 visibility:hidden;的区别"></a>dispaly:none;与 visibility:hidden;的区别</h2><p><strong>联系：</strong>它们都能让元素不可见。</p>
<p><strong>区别：</strong></p>
<ol>
<li>display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；<br>visibility:hidden;不会让元素从渲染树消失，渲染时元素继续占据空间，只是内容不可见。</li>
<li>display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。<br>visibility: hidden;是继承属性，子孙节点由于继承了 hidden 而消失，通过设置 visibility: visible，可以让子孙节点显示。</li>
<li>修改常规流中元素的 display 通常会造成文档重排。<br>修改 visibility 属性只会造成本元素的重绘。</li>
<li>读屏器不会读取 display：none;元素内容。<br>会读取 visibility：hidden；元素内容。</li>
</ol>
<h2 id="css-hack-原理及常用-hack"><a href="#css-hack-原理及常用-hack" class="headerlink" title="css hack 原理及常用 hack"></a>css hack 原理及常用 hack</h2><p><strong>原理</strong><br>利用不同浏览器对 CSS 的支持和解析结果不一样编写针对特定浏览器样式。</p>
<p><strong>常见的 hack 属性</strong></p>
<ol>
<li>属性 hack。(不同浏览器解析 bug 或方法)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* IE6 *&#x2F;</span><br><span class="line">#once &#123; _color: blue &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* IE6, IE7 *&#x2F;</span><br><span class="line">#doce &#123; *color: blue; &#x2F;* or #color: blue *&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Everything but IE6 *&#x2F;</span><br><span class="line">#diecisiete &#123; color&#x2F;**&#x2F;: blue &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* IE6, IE7, IE8 *&#x2F;</span><br><span class="line">#diecinueve &#123; color: blue\9; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* IE7, IE8 *&#x2F;</span><br><span class="line">#veinte &#123; color&#x2F;*\**&#x2F;: blue\9; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* IE6, IE7 -- acts as an !important *&#x2F;</span><br><span class="line">#veintesiete &#123; color: blue !ie; &#125; &#x2F;* string after ! can be anything</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>选择器 hack。(不同浏览器对选择器的支持不一样)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* IE6 and below *&#x2F;</span><br><span class="line">* html #uno &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* IE7 *&#x2F;</span><br><span class="line">*:first-child + html #dos &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* IE7, FF, Saf, Opera  *&#x2F;</span><br><span class="line">html &gt; body #tres &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* IE8, FF, Saf, Opera (Everything but IE 6,7) *&#x2F;</span><br><span class="line">html&gt;&#x2F;**&#x2F;body #cuatro &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Opera 9.27 and below, safari 2 *&#x2F;</span><br><span class="line">html:first-child #cinco &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Safari 2-3 *&#x2F;</span><br><span class="line">html[xmlns*&#x3D;&#39;&#39;] body:last-child #seis &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* safari 3+, chrome 1+, opera9+, ff 3.5+ *&#x2F;</span><br><span class="line">body:nth-of-type(1) #siete &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* safari 3+, chrome 1+, opera9+, ff 3.5+ *&#x2F;</span><br><span class="line">body:first-of-type #ocho &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* saf3+, chrome1+ *&#x2F;</span><br><span class="line">@media screen and (-webkit-min-device-pixel-ratio: 0) &#123;</span><br><span class="line">  #diez &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* iPhone &#x2F; mobile webkit *&#x2F;</span><br><span class="line">@media screen and (max-device-width: 480px) &#123;</span><br><span class="line">  #veintiseis &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Safari 2 - 3.1 *&#x2F;</span><br><span class="line">html[xmlns*&#x3D;&#39;&#39;]:root #trece &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Safari 2 - 3.1, Opera 9.25 *&#x2F;</span><br><span class="line">*|html[xmlns*&#x3D;&#39;&#39;] #catorce &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Everything but IE6-8 *&#x2F;</span><br><span class="line">:root * &gt; #quince &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* IE7 *&#x2F;</span><br><span class="line">* + html #dieciocho &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Firefox only. 1+ *&#x2F;</span><br><span class="line">#veinticuatro,</span><br><span class="line">x:-moz-any-link &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Firefox 3.0+ *&#x2F;</span><br><span class="line">#veinticinco,</span><br><span class="line">x:-moz-any-link,</span><br><span class="line">x:default &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>IE 条件注释（适用于[IE5, IE9]常见格式如下）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if IE 6]&gt;</span><br><span class="line">Special instructions for IE 6 here</span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure>
<h2 id="specified-value-computed-value-used-value-计算方法"><a href="#specified-value-computed-value-used-value-计算方法" class="headerlink" title="specified value,computed value,used value 计算方法"></a>specified value,computed value,used value 计算方法</h2><ol>
<li>specified value: 计算方法如下：</li>
</ol>
<ul>
<li>如果样式表设置了一个值，使用这个值</li>
<li>如果没有设值，且这个属性是继承属性，从父元素继承</li>
<li>如果没有设值，并且不是继承属性，则使用 css 规范指定的初始值</li>
</ul>
<ol start="2">
<li><p>computed value: 以 specified value 根据规范定义的行为进行计算，通常将相对值计算为绝对值，例如 em 根据 font-size 进行计算。一些使用百分数并且需要布局来决定最终值的属性，如 width，margin。百分数就直接作为 computed value。line-height 的无单位值也直接作为 computed value。这些值将在计算 used value 时得到绝对值。computed value 的主要作用是用于继承</p>
</li>
<li><p>used value：属性计算后的最终值，对于大多数属性可以通过 window.getComputedStyle 获得，尺寸值单位为像素。以下属性依赖于布局，</p>
</li>
</ol>
<ul>
<li>background-position</li>
<li>bottom, left, right, top</li>
<li>height, width</li>
<li>margin-bottom, margin-left, margin-right, margin-top</li>
<li>min-height, min-width</li>
<li>padding-bottom, padding-left, padding-right, padding-top</li>
<li>text-indent</li>
</ul>
<h2 id="link-与-import-的区别"><a href="#link-与-import-的区别" class="headerlink" title="link 与 @import 的区别"></a>link 与 @import 的区别</h2><ol>
<li>link 是 HTML 方式， @import 是 CSS 方式</li>
<li>link 最大限度支持并行下载，@import 过多嵌套导致串行下载，出现 FOUC</li>
<li>link 可以通过 rel=”alternate stylesheet”指定候选样式</li>
<li>浏览器对 link 支持早于@import，可以使用@import 对老浏览器隐藏样式</li>
<li>@import 必须在样式规则之前，可以在 css 文件中引用其他文件</li>
</ol>
<p><code>总体来说：link 优于@import</code></p>
<h2 id="display-block-和-display-inline-的区别"><a href="#display-block-和-display-inline-的区别" class="headerlink" title="display:block;和 display:inline 的区别"></a>display:block;和 display:inline 的区别</h2><ol>
<li>block 元素特点：</li>
</ol>
<ul>
<li>处于常规流中时，如果 width 没有设置，会自动填充满父容器</li>
<li>可以应用 margin/padding</li>
<li>在没有设置高度的情况下会扩展高度以包含常规流中的子元素</li>
<li>处于常规流中时布局时在前后元素位置之间（独占一个水平空间）</li>
<li>忽略 vertical-align</li>
</ul>
<ol start="2">
<li>inline 元素特点</li>
</ol>
<ul>
<li>水平方向上根据 direction 依次布局</li>
<li>不会在元素前后进行换行</li>
<li>受 white-space 控制</li>
<li>margin/padding 在竖直方向上无效，水平方向上有效</li>
<li>width/height 属性对非替换行内元素无效，宽度由元素内容决定</li>
<li>非替换行内元素的行框高由 line-height 确定，替换行内元素的行框高由 height,margin,padding,border 决定</li>
<li>浮动或绝对定位时会转换为 block</li>
<li>vertical-align 属性生效</li>
</ul>
<h2 id="PNG-GET-JPG-的区别及如何选择"><a href="#PNG-GET-JPG-的区别及如何选择" class="headerlink" title="PNG,GET,JPG 的区别及如何选择"></a>PNG,GET,JPG 的区别及如何选择</h2><h3 id="GIF"><a href="#GIF" class="headerlink" title="GIF:"></a>GIF:</h3><ol>
<li>8 位像素，256 色</li>
<li>无损压缩</li>
<li>支持简单动画</li>
<li>支持 boolean 透明</li>
<li>适合简单动画</li>
</ol>
<h3 id="JPEG："><a href="#JPEG：" class="headerlink" title="JPEG："></a>JPEG：</h3><ol>
<li>颜色限于 256</li>
<li>有损压缩</li>
<li>可控制压缩质量</li>
<li>不支持透明</li>
<li>适合照片</li>
</ol>
<h3 id="PNG："><a href="#PNG：" class="headerlink" title="PNG："></a>PNG：</h3><ol>
<li>有 PNG8 和 truecolor PNG</li>
<li>NG8 类似 GIF 颜色上限为 256，文件小，支持 alpha 透明度，无动画</li>
<li>适合图标、背景、按钮</li>
</ol>
<h2 id="web-语义化"><a href="#web-语义化" class="headerlink" title="web 语义化"></a>web 语义化</h2><p><strong>概念</strong></p>
<p>Web 语义化是指使用语义恰当的标签，使页面有良好的结构，页面元素有含义，能够让人和搜索引擎都容易理解。<br>如果可以在合适的位置使用恰当的标签，那么写出来的页面语义明确，结构清晰，搜索引擎也可以认出哪些是页面重要内容，予以较高的权值。</p>
<p><strong>好处</strong></p>
<ol>
<li>去掉或者丢失样式的时候能够让页面呈现出清晰的结构</li>
<li>有利于 SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</li>
<li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</li>
<li>便于团队开发和维护，语义化更具可读性，遵循 W3C 标准的团队都遵循这个标准，可以减少差异化。</li>
</ol>
<h2 id="offsetWidth-offsetHeight-clientWidth-clientHeight-scrollWidth-scrollHeight"><a href="#offsetWidth-offsetHeight-clientWidth-clientHeight-scrollWidth-scrollHeight" class="headerlink" title="offsetWidth,offsetHeight,clientWidth,clientHeight,scrollWidth,scrollHeight"></a>offsetWidth,offsetHeight,clientWidth,clientHeight,scrollWidth,scrollHeight</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><p>offsetWidth 返回元素的宽度（包括元素宽度、内边距和边框，不包括外边距）</p>
</li>
<li><p>offsetHeight 返回元素的高度（包括元素高度、内边距和边框，不包括外边距）</p>
</li>
<li><p>clientWidth 返回元素的宽度（包括元素宽度、内边距，不包括边框和外边距）</p>
</li>
<li><p>clientHeight 返回元素的高度（包括元素高度、内边距，不包括边框和外边距）</p>
</li>
<li><p>scrollWidth 返回元素的宽度（包括元素宽度、内边距和溢出尺寸，不包括边框和外边距），无溢出的情况，与 clientWidth 相同</p>
</li>
<li><p>scrollHeight 返回元素的高度（包括元素高度、内边距和溢出尺寸，不包括边框和外边距），无溢出的情况，与 clientHeight 相同</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/27/css%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="cl32gzik1000ihwvq05fogtw9" data-title="常考面试题1" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-深入了解观察者模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/26/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2020-01-26T10:32:01.000Z" itemprop="datePublished">2020-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/26/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">深入了解观察者模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="何为观察者模式？"><a href="#何为观察者模式？" class="headerlink" title="何为观察者模式？"></a>何为观察者模式？</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>观察者模式是一种对象行为模式，它定义对象间的一种一对多的依赖关系。</p>
<p>当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新，在观察者模式中，主体是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅并接收通知。</p>
<p>观察者模式不仅被广泛应用于软件界面元素之间的交互，在业务对象之间的交互、权限管理等方面也有广泛的应用。</p>
<p><strong>观察者模式（Observer）完美的将观察者和被观察者的对象分开，假如说用户界面可以作为一个观察者，业务数据是被观察者，用户界面观察业务数据的变化，发现数据变化后，就会显示在界面上。</strong></p>
<p><strong>简而言之观察者设计模式定义了对象间的一种一对多的组合关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。</strong></p>
<h3 id="面向对象的设计原则"><a href="#面向对象的设计原则" class="headerlink" title="面向对象的设计原则"></a>面向对象的设计原则</h3><p><code>系统中的每个类重点放在某一个功能上，而不是其他方面，一个对象只做一件事情，并且将它做好。</code></p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>观察者模式在模块之间划定了清晰的界限，提高了应用程序的可维护性和重要性。</p>
<h2 id="观察者模式的实现方式"><a href="#观察者模式的实现方式" class="headerlink" title="观察者模式的实现方式"></a>观察者模式的实现方式</h2><p>从根本上来说，<strong>该模式必须包含两个角色即观察者和被观察者对象。</strong><br>在上文的例子中业务数据是被观察对象，用户界面是观察者。<br>观察者和被观察者之间存在“观察”的逻辑关联，当被观察者发生改变的时候，观察者就会观察到这样的变化，并且做出相应的响应。<br>如果在用户界面、业务数据之间使用这样的观察过程，可以确保界面和数据之间划清界限，假定应用程序的需求发生变化，需要修改界面的表现，只需要重新构建一个用户界面，业务数据不需要发生变化。</p>
<h2 id="观察者使用场景"><a href="#观察者使用场景" class="headerlink" title="观察者使用场景"></a>观察者使用场景</h2><ol>
<li>当一个对象抽象模型有两个方面，其中一个方面依赖于另一方面。将这二者封装在独立的对象中使它们可以各自独立地改变和复用。</li>
<li>当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象需要被改变。</li>
<li>当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换而言之，不希望这些对象时紧密耦合的。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/26/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" data-id="cl32gzik80012hwvqb00caryu" data-title="深入了解观察者模式" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E7%90%86/" rel="tag">原理</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Vue中的computed与watch的区别" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/12/19/Vue%E4%B8%AD%E7%9A%84computed%E4%B8%8Ewatch%E7%9A%84%E5%8C%BA%E5%88%AB/" class="article-date">
  <time class="dt-published" datetime="2019-12-19T13:02:39.000Z" itemprop="datePublished">2019-12-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/12/19/Vue%E4%B8%AD%E7%9A%84computed%E4%B8%8Ewatch%E7%9A%84%E5%8C%BA%E5%88%AB/">Vue中的computed与watch的区别</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性 computed"></a>计算属性 computed</h2><ol>
<li>支持缓存，只有依赖数据发生改变，才会重新进行计算</li>
<li>不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化</li>
<li>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于 data 中声明过或者父组件传递的 props 中的数据通过计算得到的值</li>
<li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用 computed</li>
<li>如果 computed 属性属性值是函数，那么默认会走 get 方法；函数的返回值就是属性的属性值；在 computed 中的，属性都有一个 get 和一个 set 方法，当数据变化时，调用 set 方法。</li>
</ol>
<h2 id="侦听属性-watch："><a href="#侦听属性-watch：" class="headerlink" title="侦听属性 watch："></a>侦听属性 watch：</h2><ol>
<li>不支持缓存，数据变，直接会触发相应的操作；</li>
<li>watch 支持异步；</li>
<li>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</li>
<li>当一个属性发生变化时，需要执行对应的操作；一对多；</li>
<li>监听数据必须是 data 中声明过或者父组件传递过来的 props 中的数据，当数据变化时，触发其他操作，函数有两个参数，<br>　　 immediate：组件加载立即触发回调函数执行，<br>　　 deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep 无法监听到数组的变动和对象的新增，参考 vue 数组变异,只有以响应式的方式触发才会被监听到。</li>
</ol>
<h2 id="最大区别"><a href="#最大区别" class="headerlink" title="最大区别"></a>最大区别</h2><p><code>监听的对象也可以写成字符串的形式</code><br>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的,但是切记不可以滥用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/12/19/Vue%E4%B8%AD%E7%9A%84computed%E4%B8%8Ewatch%E7%9A%84%E5%8C%BA%E5%88%AB/" data-id="cl32gzijw000ahwvqe2ybekh3" data-title="Vue中的computed与watch的区别" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-整理proxy" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/25/%E6%95%B4%E7%90%86proxy/" class="article-date">
  <time class="dt-published" datetime="2019-11-25T08:20:01.000Z" itemprop="datePublished">2019-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/25/%E6%95%B4%E7%90%86proxy/">整理ES6语法-Proxy</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Proxy-是什么"><a href="#Proxy-是什么" class="headerlink" title="Proxy 是什么"></a>Proxy 是什么</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>Proxy 是由 ES6 原生提供的一个构造函数</strong><br><strong>Proxy 指在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</strong></p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>Proxy 的原意是代理，<strong>用在这里表示由它来“代理”某些操作，可以译为“代理器”。</strong><br>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即<strong>对编程语言进行编程</strong>。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>Proxy 作为一个构造函数，它接受两个参数。<br>第一个参数是所要代理的目标对象即<strong>target</strong><br>第二个参数是一个<strong>配置对象</strong>，对于每一个被代理的操作，需要提供一个对应的处理函数即<strong>handler</strong>，该函数将拦截对应的操作。</p>
<h3 id="配置对象的方法"><a href="#配置对象的方法" class="headerlink" title="配置对象的方法"></a>配置对象的方法</h3><p><strong>有一个 get 方法，用来拦截对目标对象属性的访问请求，而 get 方法两个参数分别是目标对象（target）和所要访问的属性（prop）。</strong><br><span style="color:red"><br>注意：要使得 Proxy 起作用，必须针对 Proxy 实例进行操作，而不是针对目标对象进行操作。<br></span></p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;new Proxy()表示生成一个Proxy实例</span><br><span class="line">var proxy &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">    get: function(target, propKey) &#123;</span><br><span class="line">        return 35;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(proxy.name) &#x2F;&#x2F; 35</span><br><span class="line">console.log(proxy.sex) &#x2F;&#x2F; 35</span><br><span class="line">console.log(proxy.age) &#x2F;&#x2F; 35</span><br><span class="line">&#x2F;&#x2F;可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果handler没有设置任何拦截，那就等同于直接通向原对象。</span><br><span class="line">var target &#x3D; &#123;&#125;;</span><br><span class="line">var handler &#x3D; &#123;&#125;;</span><br><span class="line">var proxy2 &#x3D; new Proxy(target, handler);</span><br><span class="line">proxy2.a &#x3D; &#39;b&#39;;</span><br><span class="line">target.a &#x2F;&#x2F; &quot;b&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Proxy 实例也可以作为其他对象的原型对象。</span><br><span class="line">var proxy3 &#x3D; new Proxy(&#123;&#125;,&#123;</span><br><span class="line">    return 35</span><br><span class="line">&#125;)</span><br><span class="line">let obj &#x3D; Obeject.create(proxy3)</span><br><span class="line">console.log(obj.name) &#x2F;&#x2F; 35</span><br><span class="line">&#x2F;&#x2F;上述代码proxy3对象是obj对象的原型，obj对象本身并没有name属性，所以根据原型链，会在proxy3对象上读取该属性，导致被拦截。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;同一个拦截器函数，可以设置拦截多个操作。</span><br><span class="line">var handler &#x3D; &#123;</span><br><span class="line">    get: function(target, name) &#123;</span><br><span class="line">        if (name &#x3D;&#x3D;&#x3D; &#39;prototype&#39;) &#123;</span><br><span class="line">            return Object.prototype;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#39;Hello, &#39; + name;</span><br><span class="line">    &#125;,</span><br><span class="line">    apply: function(target, thisBinding, args) &#123;</span><br><span class="line">        return args[0];</span><br><span class="line">    &#125;,</span><br><span class="line">    construct: function(target, args) &#123;</span><br><span class="line">        return &#123;value: args[1]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var fproxy &#x3D; new Proxy(function(x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;, handler);</span><br><span class="line">fproxy(1, 2) &#x2F;&#x2F; 1</span><br><span class="line">new fproxy(1, 2) &#x2F;&#x2F; &#123;value: 2&#125;</span><br><span class="line">fproxy.prototype &#x3D;&#x3D;&#x3D; Object.prototype &#x2F;&#x2F; true</span><br><span class="line">fproxy.foo &#x3D;&#x3D;&#x3D; &quot;Hello, foo&quot; &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<h2 id="Proxy-实例的方法"><a href="#Proxy-实例的方法" class="headerlink" title="Proxy 实例的方法"></a>Proxy 实例的方法</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><strong>get 方法用于拦截某个属性的读取操作。</strong><br><strong>可以接受三个参数</strong></p>
<ol>
<li>目标对象（target）</li>
<li>属性名（prop）</li>
<li>proxy 实例本身（receiver）（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</li>
</ol>
<h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p><strong>用来拦截某个属性的赋值操作。</strong><br><strong>可以接受四个参数</strong></p>
<ol>
<li>目标对象（target）</li>
<li>属性名（prop）</li>
<li>属性值（value）</li>
<li>Proxy 实例本身（receiver），其中最后一个参数可选。</li>
</ol>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p><strong>apply 方法拦截函数的调用、call 和 apply 操作。</strong><br>apply 方法可以接受三个参数</p>
<ol>
<li>目标对象 target）</li>
<li>目标对象的上下文对象（ctx）</li>
<li>目标对象的参数数组（…arguments）</li>
</ol>
<h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p><strong>has()方法用来拦截 HasProperty 操作，即判断对象是否具有某个属性时，这个方法会生效。</strong>————典型的操作就是 in 运算符。<br>has()方法可以接受两个参数</p>
<ol>
<li>目标对象</li>
<li>需查询的属性名。</li>
</ol>
<h3 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h3><p><strong>用于拦截 new 命令，下面是拦截对象的写法。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const handler &#x3D; &#123;</span><br><span class="line">  construct (target, args, newTarget) &#123;</span><br><span class="line">    return new target(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>construct() 可以接受三个参数</p>
<ol>
<li>target：目标对象。</li>
<li>args：构造函数的参数数组。</li>
<li>newTarget：创造实例对象时，new 命令作用的构造函数。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const p &#x3D; new Proxy(function () &#123;&#125;, &#123;</span><br><span class="line">  construct: function(target, args) &#123;</span><br><span class="line">    console.log(&#39;called: &#39; + args.join(&#39;, &#39;));</span><br><span class="line">    return &#123; value: args[0] * 10 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(new p(1)).value</span><br><span class="line">&#x2F;&#x2F; &quot;called: 1&quot;</span><br><span class="line">&#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong><br><span style="color:red"><br>由于 construct()拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。<br>construct()方法中的 this 指向的是 handler，而不是实例对象。<br></span></p>
<h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h3><h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h3><h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h3><h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h3><h3 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h3><h3 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h3><h3 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h3><h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/25/%E6%95%B4%E7%90%86proxy/" data-id="cl32gzik6000xhwvq32kydj2u" data-title="整理ES6语法-Proxy" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/" rel="tag">ES6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-TypeScript-接口和类" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/31/TypeScript-%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB/" class="article-date">
  <time class="dt-published" datetime="2019-10-31T11:41:39.000Z" itemprop="datePublished">2019-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/31/TypeScript-%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB/">TypeScript-接口和类</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>
<h3 id="接口初探"><a href="#接口初探" class="headerlink" title="接口初探"></a>接口初探</h3><p>下面通过一个简单示例来观察接口是如何工作的：</p>
<p>function printLabel(labelledObj: { label: string }) {<br>  console.log(labelledObj.label);<br>}</p>
<p>let myObj = { size: 10, label: “Size 10 Object” };<br>printLabel(myObj);<br>类型检查器会查看printLabel的调用。 printLabel有一个参数，并要求这个对象参数有一个名为label类型为string的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候TypeScript却并不会这么宽松，我们下面会稍做讲解。</p>
<p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个label属性且类型为string：</p>
<p>interface LabelledValue {<br>  label: string;<br>}</p>
<p>function printLabel(labelledObj: LabelledValue) {<br>  console.log(labelledObj.label);<br>}</p>
<p>let myObj = {size: 10, label: “Size 10 Object”};<br>printLabel(myObj);<br>LabelledValue接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 label属性且类型为string的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 printLabel的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p>
<p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p>
<h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p>
<p>下面是应用了“option bags”的例子：</p>
<p>interface SquareConfig {<br>  color?: string;<br>  width?: number;<br>}</p>
<p>function createSquare(config: SquareConfig): {color: string; area: number} {<br>  let newSquare = {color: “white”, area: 100};<br>  if (config.color) {<br>    newSquare.color = config.color;<br>  }<br>  if (config.width) {<br>    newSquare.area = config.width * config.width;<br>  }<br>  return newSquare;<br>}</p>
<p>let mySquare = createSquare({color: “black”});<br>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。</p>
<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare里的color属性名拼错，就会得到一个错误提示：</p>
<p>interface SquareConfig {<br>  color?: string;<br>  width?: number;<br>}</p>
<p>function createSquare(config: SquareConfig): { color: string; area: number } {<br>  let newSquare = {color: “white”, area: 100};<br>  if (config.clor) {<br>    // Error: Property ‘clor’ does not exist on type ‘SquareConfig’<br>    newSquare.color = config.clor;<br>  }<br>  if (config.width) {<br>    newSquare.area = config.width * config.width;<br>  }<br>  return newSquare;<br>}</p>
<p>let mySquare = createSquare({color: “black”});</p>
<h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:</p>
<p>interface Point {<br>    readonly x: number;<br>    readonly y: number;<br>}<br>你可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。</p>
<p>let p1: Point = { x: 10, y: 20 };<br>p1.x = 5; // error!<br>TypeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</T></T></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let a: number[] &#x3D; [1, 2, 3, 4];</span><br><span class="line">let ro: ReadonlyArray&lt;number&gt; &#x3D; a;</span><br><span class="line">ro[0] &#x3D; 12; &#x2F;&#x2F; error!</span><br><span class="line">ro.push(5); &#x2F;&#x2F; error!</span><br><span class="line">ro.length &#x3D; 100; &#x2F;&#x2F; error!</span><br><span class="line">a &#x3D; ro; &#x2F;&#x2F; error!</span><br><span class="line">上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</span><br><span class="line"></span><br><span class="line">a &#x3D; ro as number[];</span><br><span class="line">readonly vs const</span><br></pre></td></tr></table></figure>
<p>最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。</p>
<h3 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h3><p>我们在第一个例子里使用了接口，TypeScript让我们传入{ size: number; label: string; }到仅期望得到{ label: string; }的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。</p>
<p>然而，天真地将这两者结合的话就会像在JavaScript里那样搬起石头砸自己的脚。 比如，拿 createSquare例子来说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">    color?: string;</span><br><span class="line">    width?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySquare &#x3D; createSquare(&#123; colour: &quot;red&quot;, width: 100 &#125;);</span><br></pre></td></tr></table></figure>
<p>注意传入createSquare的参数拼写为colour而不是color。 在JavaScript里，这会默默地失败。</p>
<p>你可能会争辩这个程序已经正确地类型化了，因为width属性是兼容的，不存在color属性，而且额外的colour属性是无意义的。</p>
<p>然而，TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p>
<p>// error: ‘colour’ not expected in type ‘SquareConfig’<br>let mySquare = createSquare({ colour: “red”, width: 100 });<br>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p>
<p>let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);<br>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：</p>
<p>interface SquareConfig {<br>    color?: string;<br>    width?: number;<br>    [propName: string]: any;<br>}<br>我们稍后会讲到索引签名，但在这我们要表示的是SquareConfig可以有任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。</p>
<p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 squareOptions不会经过额外属性检查，所以编译器不会报错。</p>
<p>let squareOptions = { colour: “red”, width: 100 };<br>let mySquare = createSquare(squareOptions);<br>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入 color或colour属性到createSquare，你应该修改SquareConfig定义来体现出这一点。</p>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<p>interface SearchFunc {<br>  (source: string, subString: string): boolean;<br>}</p>
<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>
<p>let mySearch: SearchFunc;<br>mySearch = function(source: string, subString: string) {<br>  let result = source.search(subString);<br>  return result &gt; -1;<br>}<br>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p>
<p>let mySearch: SearchFunc;<br>mySearch = function(src: string, sub: string): boolean {<br>  let result = src.search(sub);<br>  return result &gt; -1;<br>}<br>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false和true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 SearchFunc接口中的定义不匹配。</p>
<p>let mySearch: SearchFunc;<br>mySearch = function(src, sub) {<br>    let result = src.search(sub);<br>    return result &gt; -1;<br>}</p>
<h3 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h3><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[“daniel”]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p>
<p>interface StringArray {<br>  [index: number]: string;<br>}</p>
<p>let myArray: StringArray;<br>myArray = [“Bob”, “Fred”];</p>
<p>let myStr: string = myArray[0];</p>
<p>上面例子里，我们定义了StringArray接口，它具有索引签名。 这个索引签名表示了当用 number去索引StringArray时会得到string类型的返回值。</p>
<p>TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。</p>
<p>class Animal {<br>    name: string;<br>}<br>class Dog extends Animal {<br>    breed: string;<br>}</p>
<p>// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!<br>interface NotOkay {<br>    [x: number]: Animal;<br>    [x: string]: Dog;<br>}<br>字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property和obj[“property”]两种形式都可以。 下面的例子里， name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>
<p>interface NumberDictionary {<br>  [index: string]: number;<br>  length: number;    // 可以，length是number类型<br>  name: string       // 错误，<code>name</code>的类型与索引类型返回值的类型不匹配<br>}<br>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>
<p>interface ReadonlyStringArray {<br>    readonly [index: number]: string;<br>}<br>let myArray: ReadonlyStringArray = [“Alice”, “Bob”];<br>myArray[2] = “Mallory”; // error!<br>你不能设置myArray[2]，因为索引签名是只读的。</p>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>实现接口<br>与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。</p>
<p>interface ClockInterface {<br>    currentTime: Date;<br>}</p>
<p>class Clock implements ClockInterface {<br>    currentTime: Date;<br>    constructor(h: number, m: number) { }<br>}<br>你也可以在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样：</p>
<p>interface ClockInterface {<br>    currentTime: Date;<br>    setTime(d: Date);<br>}</p>
<p>class Clock implements ClockInterface {<br>    currentTime: Date;<br>    setTime(d: Date) {<br>        this.currentTime = d;<br>    }<br>    constructor(h: number, m: number) { }<br>}<br>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p>
<p>类静态部分与实例部分的区别<br>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p>
<p>interface ClockConstructor {<br>    new (hour: number, minute: number);<br>}</p>
<p>class Clock implements ClockConstructor {<br>    currentTime: Date;<br>    constructor(h: number, m: number) { }<br>}</p>
<p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。</p>
<p>因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口， ClockConstructor为构造函数所用和ClockInterface为实例方法所用。 为了方便我们定义一个构造函数 createClock，它用传入的类型创建实例。</p>
<p>interface ClockConstructor {<br>    new (hour: number, minute: number): ClockInterface;<br>}<br>interface ClockInterface {<br>    tick();<br>}</p>
<p>function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {<br>    return new ctor(hour, minute);<br>}</p>
<p>class DigitalClock implements ClockInterface {<br>    constructor(h: number, m: number) { }<br>    tick() {<br>        console.log(“beep beep”);<br>    }<br>}<br>class AnalogClock implements ClockInterface {<br>    constructor(h: number, m: number) { }<br>    tick() {<br>        console.log(“tick tock”);<br>    }<br>}</p>
<p>let digital = createClock(DigitalClock, 12, 17);<br>let analog = createClock(AnalogClock, 7, 32);<br>因为createClock的第一个参数是ClockConstructor类型，在createClock(AnalogClock, 7, 32)里，会检查AnalogClock是否符合构造函数签名。</p>
<h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<p>interface Shape {<br>    color: string;<br>}</p>
<p>interface Square extends Shape {<br>    sideLength: number;<br>}</p>
<p>let square = <Square>{};<br>square.color = “blue”;<br>square.sideLength = 10;<br>一个接口可以继承多个接口，创建出多个接口的合成接口。</Square></p>
<p>interface Shape {<br>    color: string;<br>}</p>
<p>interface PenStroke {<br>    penWidth: number;<br>}</p>
<p>interface Square extends Shape, PenStroke {<br>    sideLength: number;<br>}</p>
<p>let square = <Square>{};<br>square.color = “blue”;<br>square.sideLength = 10;<br>square.penWidth = 5.0;<br>混合类型<br>先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</Square></p>
<p>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p>
<p>interface Counter {<br>    (start: number): string;<br>    interval: number;<br>    reset(): void;<br>}</p>
<p>function getCounter(): Counter {<br>    let counter = <Counter>function (start: number) { };<br>    counter.interval = 123;<br>    counter.reset = function () { };<br>    return counter;<br>}</Counter></p>
<p>let c = getCounter();<br>c(10);<br>c.reset();<br>c.interval = 5.0;<br>在使用JavaScript第三方库的时候，你可能需要像上面那样去完整地定义类型。</p>
<h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p>
<p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。 例：</p>
<p>class Control {<br>    private state: any;<br>}</p>
<p>interface SelectableControl extends Control {<br>    select(): void;<br>}</p>
<p>class Button extends Control implements SelectableControl {<br>    select() { }<br>}</p>
<p>class TextBox extends Control {<br>    select() { }<br>}</p>
<p>// 错误：“Image”类型缺少“state”属性。<br>class Image implements SelectableControl {<br>    select() { }<br>}</p>
<p>class Location {</p>
<p>}<br>在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为 state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有 Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。</p>
<p>在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上， SelectableControl接口和拥有select方法的Control类是一样的。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。</p>
<h3 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h3><p>下面看一个使用类的例子：</p>
<p>class Greeter {<br>    greeting: string;<br>    constructor(message: string) {<br>        this.greeting = message;<br>    }<br>    greet() {<br>        return “Hello, “ + this.greeting;<br>    }<br>}</p>
<p>let greeter = new Greeter(“world”);<br>如果你使用过C#或Java，你会对这种语法非常熟悉。 我们声明一个 Greeter类。这个类有3个成员：一个叫做 greeting的属性，一个构造函数和一个 greet方法。</p>
<p>你会注意到，我们在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。</p>
<p>最后一行，我们使用 new构造了 Greeter类的一个实例。 它会调用之前定义的构造函数，创建一个 Greeter类型的新对象，并执行构造函数初始化它。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p>
<p>看下面的例子：</p>
<p>class Animal {<br>    move(distanceInMeters: number = 0) {<br>        console.log(<code>Animal moved $&#123;distanceInMeters&#125;m.</code>);<br>    }<br>}</p>
<p>class Dog extends Animal {<br>    bark() {<br>        console.log(‘Woof! Woof!’);<br>    }<br>}</p>
<p>const dog = new Dog();<br>dog.bark();<br>dog.move(10);<br>dog.bark();<br>这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里， Dog是一个 派生类，它派生自 Animal 基类，通过 extends关键字。 派生类通常被称作 子类，基类通常被称作 超类。</p>
<p>因为 Dog继承了 Animal的功能，因此我们可以创建一个 Dog的实例，它能够 bark()和 move()。</p>
<p>下面我们来看个更加复杂的例子。</p>
<p>class Animal {<br>    name: string;<br>    constructor(theName: string) { this.name = theName; }<br>    move(distanceInMeters: number = 0) {<br>        console.log(<code>$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.</code>);<br>    }<br>}</p>
<p>class Snake extends Animal {<br>    constructor(name: string) { super(name); }<br>    move(distanceInMeters = 5) {<br>        console.log(“Slithering…”);<br>        super.move(distanceInMeters);<br>    }<br>}</p>
<p>class Horse extends Animal {<br>    constructor(name: string) { super(name); }<br>    move(distanceInMeters = 45) {<br>        console.log(“Galloping…”);<br>        super.move(distanceInMeters);<br>    }<br>}</p>
<p>let sam = new Snake(“Sammy the Python”);<br>let tom: Animal = new Horse(“Tommy the Palomino”);</p>
<p>sam.move();<br>tom.move(34);<br>这个例子展示了一些上面没有提到的特性。 这一次，我们使用 extends关键字创建了 Animal的两个子类： Horse和 Snake。</p>
<p>与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，我们 一定要调用 super()。 这个是TypeScript强制执行的一条重要规则。</p>
<p>这个例子演示了如何在子类里可以重写父类的方法。 Snake类和 Horse类都创建了 move方法，它们重写了从 Animal继承来的 move方法，使得 move方法根据不同的类而具有不同的功能。 注意，即使 tom被声明为 Animal类型，但因为它的值是 Horse，调用 tom.move(34)时，它会调用 Horse里重写的方法：</p>
<p>Slithering…<br>Sammy the Python moved 5m.<br>Galloping…<br>Tommy the Palomino moved 34m.<br>公共，私有与受保护的修饰符<br>默认为 public<br>在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 public来做修饰；例如，C#要求必须明确地使用 public指定成员是可见的。 在TypeScript里，成员都默认为 public。</p>
<p>你也可以明确的将一个成员标记成 public。 我们可以用下面的方式来重写上面的 Animal类：</p>
<p>class Animal {<br>    public name: string;<br>    public constructor(theName: string) { this.name = theName; }<br>    public move(distanceInMeters: number) {<br>        console.log(<code>$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.</code>);<br>    }<br>}</p>
<h3 id="理解-private"><a href="#理解-private" class="headerlink" title="理解 private"></a>理解 private</h3><p>当成员被标记成 private时，它就不能在声明它的类的外部访问。比如：</p>
<p>class Animal {<br>    private name: string;<br>    constructor(theName: string) { this.name = theName; }<br>}</p>
<p>new Animal(“Cat”).name; // 错误: ‘name’ 是私有的.<br>TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。</p>
<p>然而，当我们比较带有 private或 protected成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个 private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected成员也使用这个规则。</p>
<p>下面来看一个例子，更好地说明了这一点：</p>
<p>class Animal {<br>    private name: string;<br>    constructor(theName: string) { this.name = theName; }<br>}</p>
<p>class Rhino extends Animal {<br>    constructor() { super(“Rhino”); }<br>}</p>
<p>class Employee {<br>    private name: string;<br>    constructor(theName: string) { this.name = theName; }<br>}</p>
<p>let animal = new Animal(“Goat”);<br>let rhino = new Rhino();<br>let employee = new Employee(“Bob”);</p>
<p>animal = rhino;<br>animal = employee; // 错误: Animal 与 Employee 不兼容.<br>这个例子中有 Animal和 Rhino两个类， Rhino是 Animal类的子类。 还有一个 Employee类，其类型看上去与 Animal是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 Animal和 Rhino共享了来自 Animal里的私有成员定义 private name: string，因此它们是兼容的。 然而 Employee却不是这样。当把 Employee赋值给 Animal的时候，得到一个错误，说它们的类型不兼容。 尽管 Employee里也有一个私有成员 name，但它明显不是 Animal里面定义的那个。</p>
<h3 id="理解-protected"><a href="#理解-protected" class="headerlink" title="理解 protected"></a>理解 protected</h3><p>protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问。例如：</p>
<p>class Person {<br>    protected name: string;<br>    constructor(name: string) { this.name = name; }<br>}</p>
<p>class Employee extends Person {<br>    private department: string;</p>
<pre><code>constructor(name: string, department: string) &#123;
    super(name)
    this.department = department;
&#125;

public getElevatorPitch() &#123;
    return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`;
&#125;</code></pre>
<p>}</p>
<p>let howard = new Employee(“Howard”, “Sales”);<br>console.log(howard.getElevatorPitch());<br>console.log(howard.name); // 错误</p>
<p>注意，我们不能在 Person类外使用 name，但是我们仍然可以通过 Employee类的实例方法访问，因为 Employee是由 Person派生而来的。</p>
<p>构造函数也可以被标记成 protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如，</p>
<p>class Person {<br>    protected name: string;<br>    protected constructor(theName: string) { this.name = theName; }<br>}</p>
<p>// Employee 能够继承 Person<br>class Employee extends Person {<br>    private department: string;</p>
<pre><code>constructor(name: string, department: string) &#123;
    super(name);
    this.department = department;
&#125;

public getElevatorPitch() &#123;
    return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`;
&#125;</code></pre>
<p>}</p>
<p>let howard = new Employee(“Howard”, “Sales”);<br>let john = new Person(“John”); // 错误: ‘Person’ 的构造函数是被保护的.<br>readonly修饰符<br>你可以使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p>
<p>class Octopus {<br>    readonly name: string;<br>    readonly numberOfLegs: number = 8;<br>    constructor (theName: string) {<br>        this.name = theName;<br>    }<br>}<br>let dad = new Octopus(“Man with the 8 strong legs”);<br>dad.name = “Man with the 3-piece suit”; // 错误! name 是只读的.</p>
<h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>在上面的例子中，我们必须在Octopus类里定义一个只读成员 name和一个参数为 theName的构造函数，并且立刻将 theName的值赋给 name，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 Octopus类的修改版，使用了参数属性：</p>
<p>class Octopus {<br>    readonly numberOfLegs: number = 8;<br>    constructor(readonly name: string) {<br>    }<br>}</p>
<p>注意看我们是如何舍弃了 theName，仅在构造函数里使用 readonly name: string参数来创建和初始化 name成员。 我们把声明和赋值合并至一处。</p>
<p>参数属性通过给构造函数参数前面添加一个访问限定符来声明。 使用 private限定一个参数属性会声明并初始化一个私有成员；对于 public和 protected来说也是一样。</p>
<h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p>
<p>下面来看如何把一个简单的类改写成使用 get和 set。 首先，我们从一个没有使用存取器的例子开始。</p>
<p>class Employee {<br>    fullName: string;<br>}</p>
<p>let employee = new Employee();<br>employee.fullName = “Bob Smith”;<br>if (employee.fullName) {<br>    console.log(employee.fullName);<br>}<br>我们可以随意的设置 fullName，这是非常方便的，但是这也可能会带来麻烦。</p>
<p>下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。 我们把对 fullName的直接访问改成了可以检查密码的 set方法。 我们也加了一个 get方法，让上面的例子仍然可以工作。</p>
<p>let passcode = “secret passcode”;</p>
<p>class Employee {<br>    private _fullName: string;</p>
<pre><code>get fullName(): string &#123;
    return this._fullName;
&#125;

set fullName(newName: string) &#123;
    if (passcode &amp;&amp; passcode == &quot;secret passcode&quot;) &#123;
        this._fullName = newName;
    &#125;
    else &#123;
        console.log(&quot;Error: Unauthorized update of employee!&quot;);
    &#125;
&#125;</code></pre>
<p>}</p>
<p>let employee = new Employee();<br>employee.fullName = “Bob Smith”;<br>if (employee.fullName) {<br>    alert(employee.fullName);<br>}<br>我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。</p>
<p>对于存取器有下面几点需要注意的：</p>
<p>首先，存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有 get不带有 set的存取器自动被推断为 readonly。 这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</p>
<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 static定义 origin，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 origin前面加上类名。 如同在实例属性上使用 this.前缀来访问属性一样，这里我们使用 Grid.来访问静态属性。</p>
<p>class Grid {<br>    static origin = {x: 0, y: 0};<br>    calculateDistanceFromOrigin(point: {x: number; y: number;}) {<br>        let xDist = (point.x - Grid.origin.x);<br>        let yDist = (point.y - Grid.origin.y);<br>        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;<br>    }<br>    constructor (public scale: number) { }<br>}</p>
<p>let grid1 = new Grid(1.0);  // 1x scale<br>let grid2 = new Grid(5.0);  // 5x scale</p>
<p>console.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));<br>console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>
<p>abstract class Animal {<br>    abstract makeSound(): void;<br>    move(): void {<br>        console.log(‘roaming the earch…’);<br>    }<br>}</p>
<p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 abstract关键字并且可以包含访问修饰符。</p>
<p>abstract class Department {</p>
<pre><code>constructor(public name: string) &#123;
&#125;

printName(): void &#123;
    console.log(&#39;Department name: &#39; + this.name);
&#125;

abstract printMeeting(): void; // 必须在派生类中实现</code></pre>
<p>}</p>
<p>class AccountingDepartment extends Department {</p>
<pre><code>constructor() &#123;
    super(&#39;Accounting and Auditing&#39;); // 在派生类的构造函数中必须调用 super()
&#125;

printMeeting(): void &#123;
    console.log(&#39;The Accounting Department meets each Monday at 10am.&#39;);
&#125;

generateReports(): void &#123;
    console.log(&#39;Generating accounting reports...&#39;);
&#125;</code></pre>
<p>}</p>
<p>let department: Department; // 允许创建一个对抽象类型的引用<br>department = new Department(); // 错误: 不能创建一个抽象类的实例<br>department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值<br>department.printName();<br>department.printMeeting();<br>department.generateReports(); // 错误: 方法在声明的抽象类中不存在</p>
<h3 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h3><h4 id="1、构造函数"><a href="#1、构造函数" class="headerlink" title="1、构造函数"></a>1、构造函数</h4><p>当你在TypeScript里声明了一个类的时候，实际上同时声明了很多东西。 首先就是类的 实例的类型。</p>
<p>class Greeter {<br>    greeting: string;<br>    constructor(message: string) {<br>        this.greeting = message;<br>    }<br>    greet() {<br>        return “Hello, “ + this.greeting;<br>    }<br>}</p>
<p>let greeter: Greeter;<br>greeter = new Greeter(“world”);<br>console.log(greeter.greet());</p>
<p>这里，我们写了 let greeter: Greeter，意思是 Greeter类的实例的类型是 Greeter。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。</p>
<p>我们也创建了一个叫做 构造函数的值。 这个函数会在我们使用 new创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：</p>
<p>let Greeter = (function () {<br>    function Greeter(message) {<br>        this.greeting = message;<br>    }<br>    Greeter.prototype.greet = function () {<br>        return “Hello, “ + this.greeting;<br>    };<br>    return Greeter;<br>})();</p>
<p>let greeter;<br>greeter = new Greeter(“world”);<br>console.log(greeter.greet());<br>上面的代码里， let Greeter将被赋值为构造函数。 当我们调用 new并执行了这个函数后，便会得到一个类的实例。 这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有 实例部分与 静态部分这两个部分。</p>
<p>让我们稍微改写一下这个例子，看看它们之间的区别：</p>
<p>class Greeter {<br>    static standardGreeting = “Hello, there”;<br>    greeting: string;<br>    greet() {<br>        if (this.greeting) {<br>            return “Hello, “ + this.greeting;<br>        }<br>        else {<br>            return Greeter.standardGreeting;<br>        }<br>    }<br>}</p>
<p>let greeter1: Greeter;<br>greeter1 = new Greeter();<br>console.log(greeter1.greet());</p>
<p>let greeterMaker: typeof Greeter = Greeter;<br>greeterMaker.standardGreeting = “Hey there!”;</p>
<p>let greeter2: Greeter = new greeterMaker();<br>console.log(greeter2.greet());<br>这个例子里， greeter1与之前看到的一样。 我们实例化 Greeter类，并使用这个对象。 与我们之前看到的一样。</p>
<p>再之后，我们直接使用类。 我们创建了一个叫做 greeterMaker的变量。 这个变量保存了这个类或者说保存了类构造函数。 然后我们使用 typeof Greeter，意思是取Greeter类的类型，而不是实例的类型。 或者更确切的说，”告诉我 Greeter标识符的类型”，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 greeterMaker上使用 new，创建 Greeter的实例。</p>
<h4 id="2、把类当做接口使用"><a href="#2、把类当做接口使用" class="headerlink" title="2、把类当做接口使用"></a>2、把类当做接口使用</h4><p>如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。</p>
<p>class Point {<br>    x: number;<br>    y: number;<br>}</p>
<p>interface Point3d extends Point {<br>    z: number;<br>}</p>
<p>let point3d: Point3d = {x: 1, y: 2, z: 3};</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/31/TypeScript-%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB/" data-id="cl32gzikf001mhwvqb8eo7hil" data-title="TypeScript-接口和类" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TS/" rel="tag">TS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ajax、fetch、axios的关系" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/03/10/ajax%E3%80%81fetch%E3%80%81axios%E7%9A%84%E5%85%B3%E7%B3%BB/" class="article-date">
  <time class="dt-published" datetime="2019-03-09T23:53:15.000Z" itemprop="datePublished">2019-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/03/10/ajax%E3%80%81fetch%E3%80%81axios%E7%9A%84%E5%85%B3%E7%B3%BB/">ajax、fetch、axios的关系</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="ajax-与-fetch-的区别？"><a href="#ajax-与-fetch-的区别？" class="headerlink" title="ajax 与 fetch 的区别？"></a>ajax 与 fetch 的区别？</h2><ul>
<li>ajax 是使用 XMLHttpRequest 对象发起的，但是用起来很麻烦，所以 ES6 新规范就有了 fetch，fetch 发一个请求不用像 ajax 那样写一大堆代码。</li>
<li>使用 fetch 无法取消一个请求，这是因为 fetch 基于 Promise，而 Promise 无法做到这一点。</li>
<li>在默认情况下，fetch 不会接受或者发送 cookies</li>
<li>fetch 没有办法原生监测请求的进度，而 XMLHttpRequest 可以</li>
<li>fetch 只对网络请求报错，对 400，500 都当做成功的请求，需要封装去处理</li>
<li>fetch 由于是 ES6 规范，兼容性上比不上 XMLHttpRequest</li>
</ul>
<h2 id="ajax-与-axios-的区别及缺点？"><a href="#ajax-与-axios-的区别及缺点？" class="headerlink" title="ajax 与 axios 的区别及缺点？"></a>ajax 与 axios 的区别及缺点？</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><strong>axios 是通过 Promise 实现对 ajax 技术的一种封装，简单来说就是 ajax 技术实现了局部数据的刷新，axios 实现了对 ajax 的封装，axios 有的 ajax 都有，ajax 有的 axios 不一定有。</strong></p>
<p>总结一句话就是 axios 是 ajax，ajax 不止 axios</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><strong>ajax：</strong></p>
<ul>
<li>本身是针对 MVC 编程，不符合前端 MVVM 的浪潮</li>
<li>基于原生 XHR 开发，XHR 本身的架构不清晰，已经有了 fetch 的替代方案</li>
<li>ajax 不支持浏览器的 back 按钮</li>
<li>安全问题 ajax 暴露了与服务器交互的细节</li>
<li>对搜索引擎的支持比较弱</li>
<li>破坏程序的异常机制</li>
<li>不容易调试</li>
</ul>
<p><strong>axios：</strong></p>
<ul>
<li>从 node.js 创建 http 请求</li>
<li>支持 Promise API</li>
<li>客户端防止 CSRF（网站恶意利用）</li>
<li>提供了一些并发请求的接口</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/03/10/ajax%E3%80%81fetch%E3%80%81axios%E7%9A%84%E5%85%B3%E7%B3%BB/" data-id="cl32gzijy000ehwvq9edn2gjq" data-title="ajax、fetch、axios的关系" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-严格模式和变量提升" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/02/01/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/" class="article-date">
  <time class="dt-published" datetime="2019-02-01T13:08:10.000Z" itemprop="datePublished">2019-02-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/02/01/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/">严格模式和变量提升</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>使用 “use strict” 指令<br>“use strict” 指令在 JavaScript 1.8.5 (ECMAScript5) 中新增。</p>
<p>它不是一条语句，但是是一个字面量表达式，在 JavaScript 旧版本中会被忽略。</p>
<p>“use strict” 的目的是指定代码在严格条件下执行。</p>
<p>严格模式下你不能使用未声明的变量。</p>
<p>Note    支持严格模式的浏览器:<br>Internet Explorer 10 +、 Firefox 4+ Chrome 13+、 Safari 5.1+、 Opera 12+。<br>严格模式声明<br>严格模式通过在脚本或函数的头部添加 use strict; 表达式来声明。</p>
<p>实例中我们可以在浏览器按下 F12 (或点击”工具&gt;更多工具&gt;开发者工具”) 开启调试模式，查看报错信息。</p>
<p>也可以通过右击鼠标，选择 “检查” 来查看，Gif 图演示如下：</p>
<p>实例<br>“use strict”;<br>x = 3.14;       // 报错 (x 未定义)</p>
<p>尝试一下 »</p>
<p>实例<br>“use strict”;<br>myFunction();</p>
<p>function myFunction() {<br>    y = 3.14;   // 报错 (y 未定义)<br>}</p>
<p>尝试一下 »<br>在函数内部声明是局部作用域 (只在函数内使用严格模式):</p>
<p>实例<br>x = 3.14;       // 不报错<br>myFunction();</p>
<p>function myFunction() {<br>   “use strict”;<br>    y = 3.14;   // 报错 (y 未定义)<br>}</p>
<p>尝试一下 »<br>为什么使用严格模式:</p>
<p>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;<br>消除代码运行的一些不安全之处，保证代码运行的安全；<br>提高编译器效率，增加运行速度；<br>为未来新版本的Javascript做好铺垫。<br>“严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。</p>
<p>另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。</p>
<p>严格模式的限制<br>不允许使用未声明的变量：</p>
<p>“use strict”;<br>x = 3.14;                // 报错 (x 未定义)</p>
<p>尝试一下 »<br>Note    对象也是一个变量。</p>
<p>“use strict”;<br>x = {p1:10, p2:20};      // 报错 (x 未定义)</p>
<p>尝试一下 »<br>不允许删除变量或对象。</p>
<p>“use strict”;<br>var x = 3.14;<br>delete x;                // 报错</p>
<p>尝试一下 »<br>不允许删除函数。</p>
<p>“use strict”;<br>function x(p1, p2) {};<br>delete x;                // 报错 </p>
<p>尝试一下 »<br>不允许变量重名:</p>
<p>“use strict”;<br>function x(p1, p1) {};   // 报错</p>
<p>尝试一下 »<br>不允许使用八进制:</p>
<p>“use strict”;<br>var x = 010;             // 报错</p>
<p>尝试一下 »<br>不允许使用转义字符:</p>
<p>“use strict”;<br>var x = \010;            // 报错</p>
<p>尝试一下 »<br>不允许对只读属性赋值:</p>
<p>“use strict”;<br>var obj = {};<br>Object.defineProperty(obj, “x”, {value:0, writable:false});</p>
<p>obj.x = 3.14;            // 报错</p>
<p>尝试一下 »<br>不允许对一个使用getter方法读取的属性进行赋值</p>
<p>“use strict”;<br>var obj = {get x() {return 0} };</p>
<p>obj.x = 3.14;            // 报错</p>
<p>尝试一下 »<br>不允许删除一个不允许删除的属性：</p>
<p>“use strict”;<br>delete Object.prototype; // 报错</p>
<p>尝试一下 »<br>变量名不能使用 “eval” 字符串:</p>
<p>“use strict”;<br>var eval = 3.14;         // 报错</p>
<p>尝试一下 »<br>变量名不能使用 “arguments” 字符串:</p>
<p>“use strict”;<br>var arguments = 3.14;    // 报错</p>
<p>尝试一下 »<br>不允许使用以下这种语句:</p>
<p>“use strict”;<br>with (Math){x = cos(2)}; // 报错</p>
<p>尝试一下 »<br>由于一些安全原因，在作用域 eval() 创建的变量不能被调用：</p>
<p>“use strict”;<br>eval (“var x = 2”);<br>alert (x);               // 报错</p>
<p>尝试一下 »<br>禁止this关键字指向全局对象。</p>
<p>function f(){<br>    return !this;<br>}<br>// 返回false，因为”this”指向全局对象，”!this”就是false</p>
<p>function f(){<br>    “use strict”;<br>    return !this;<br>}<br>// 返回true，因为严格模式下，this的值为undefined，所以”!this”为true。<br>因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。</p>
<p>function f(){<br>    “use strict”;<br>    this.a = 1;<br>};<br>f();// 报错，this未定义<br>保留关键字<br>为了向将来Javascript的新版本过渡，严格模式新增了一些保留关键字：</p>
<p>implements<br>interface<br>let<br>package<br>private<br>protected<br>public<br>static<br>yield<br>“use strict”;<br>var public = 1500;      // 报错</p>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。</p>
<p>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</p>
<p>以下两个实例将获得相同的结果：</p>
<p>实例 1<br>x = 5; // 变量 x 设置为 5</p>
<p>elem = document.getElementById(“demo”); // 查找元素<br>elem.innerHTML = x;                     // 在元素中显示 x</p>
<p>var x; // 声明 x</p>
<p>尝试一下 »</p>
<p>实例 2<br>var x; // 声明 x<br>x = 5; // 变量 x 设置为 5</p>
<p>elem = document.getElementById(“demo”); // 查找元素<br>elem.innerHTML = x;                     // 在元素中显示 x</p>
<p>尝试一下 »<br>要理解以上实例就需要理解 “hoisting(变量提升)”。</p>
<p>变量提升：函数声明和变量声明总是会被解释器悄悄地被”提升”到方法体的最顶部。</p>
<p>JavaScript 初始化不会提升<br>JavaScript 只有声明的变量会提升，初始化的不会。</p>
<p>以下两个实例结果结果不相同：</p>
<p>实例 1<br>var x = 5; // 初始化 x<br>var y = 7; // 初始化 y</p>
<p>elem = document.getElementById(“demo”); // 查找元素<br>elem.innerHTML = x + “ “ + y;           // 显示 x 和 y</p>
<p>尝试一下 »</p>
<p>实例 2<br>var x = 5; // 初始化 x</p>
<p>elem = document.getElementById(“demo”); // 查找元素<br>elem.innerHTML = x + “ “ + y;           // 显示 x 和 y</p>
<p>var y = 7; // 初始化 y</p>
<p>尝试一下 »<br>实例 2 的 y 输出了 undefined，这是因为变量声明 (var y) 提升了，但是初始化(y = 7) 并不会提升，所以 y 变量是一个未定义的变量。</p>
<p>实例 2 类似以下代码:</p>
<p>var x = 5; // 初始化 x<br>var y;     // 声明 y</p>
<p>elem = document.getElementById(“demo”); // 查找元素<br>elem.innerHTML = x + “ “ + y;           // 显示 x 和 y</p>
<p>y = 7;    // 设置 y 为 7<br>在头部声明你的变量<br>对于大多数程序员来说并不知道 JavaScript 变量提升。</p>
<p>如果程序员不能很好的理解变量提升，他们写的程序就容易出现一些问题。</p>
<p>为了避免这些问题，通常我们在每个作用域开始前声明这些变量，这也是正常的 JavaScript 解析步骤，易于我们理解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/02/01/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/" data-id="cl32gzik3000nhwvqb6z30lfd" data-title="严格模式和变量提升" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-阐述深浅拷贝" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/01/26/%E9%98%90%E8%BF%B0%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="article-date">
  <time class="dt-published" datetime="2019-01-26T01:02:49.000Z" itemprop="datePublished">2019-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/01/26/%E9%98%90%E8%BF%B0%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/">阐述深浅拷贝</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>说起深浅拷贝离不开JavaScript的基本类型，我们首先说说JavaScript的数据类型与复制两种数据类型的区别。</p>
<h3 id="1、JS数据类型"><a href="#1、JS数据类型" class="headerlink" title="1、JS数据类型"></a>1、JS数据类型</h3><p>javaScritp的数据类型有：数值类型、字符串类型、布尔类型、空、undefined、对象(数组、正则表达式、日期、函数)，大致分成两种：基本数据类型和引用数据类型。<br>1、基本数据类型：数值、字符串、布尔、空、undefined （值类型）、symbol(ES6新增)<br>2、复杂(复合)数据类型：对象 (引用类型)；<br><strong>基本数据类型</strong>保存在<strong>栈内存</strong>，<strong>引用类型</strong>保存在<strong>堆内存</strong>中。<br><strong>根本原因</strong>在于保存在栈内存的必须是大小固定的数据，引用类型的大小不固定，只能保存在堆内存中，但是可以把它的地址写在栈内存中以供我们访问。<br><strong>如果是基本数据类型，则按值访问，操作的就是变量保存的值；如果是引用类型的值，我们只是通过保存在变量中的引用类型的地址来操作实际对象。</strong></p>
<h3 id="2、复制基本类型数据"><a href="#2、复制基本类型数据" class="headerlink" title="2、复制基本类型数据"></a>2、复制基本类型数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">var b &#x3D; a;&#x2F;&#x2F;复制</span><br><span class="line">console.log(b)&#x2F;&#x2F;1；</span><br><span class="line">a &#x3D; 2;&#x2F;&#x2F;改变a的值</span><br><span class="line">console.log(b)&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>
<p><strong>赋值的时候，在栈内存中重新开辟内存，存放变量b，所以在栈内存中分别存放着变量a、b各自的值，修改时互不影响。</strong></p>
<h3 id="3、复制复杂类型的数据"><a href="#3、复制复杂类型的数据" class="headerlink" title="3、复制复杂类型的数据"></a>3、复制复杂类型的数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var color1 &#x3D; [&#39;red&#39;,&#39;green&#39;];</span><br><span class="line">var color2 &#x3D; color1;&#x2F;&#x2F;复制</span><br><span class="line">console.log(color2)&#x2F;&#x2F;[&#39;red&#39;,&#39;green&#39;];</span><br><span class="line">color1.push(&#39;black&#39;) ;&#x2F;&#x2F;改变color1的值</span><br><span class="line">console.log(color2)&#x2F;&#x2F;[&#39;red&#39;,&#39;green&#39;,&#39;black&#39;]</span><br></pre></td></tr></table></figure>
<p><strong>color1与color2指向堆内存中同一地址的同一对象，复制的只是引用地址</strong><br><strong>因此，对于引用类型的复制，简单赋值无用，需要拷贝。拷贝存在两种类型：深拷贝与浅拷贝</strong></p>
<h2 id="深浅拷贝的应用"><a href="#深浅拷贝的应用" class="headerlink" title="深浅拷贝的应用"></a>深浅拷贝的应用</h2><h3 id="1、浅拷贝的实现方式"><a href="#1、浅拷贝的实现方式" class="headerlink" title="1、浅拷贝的实现方式"></a>1、浅拷贝的实现方式</h3><p>（1）<strong>Object.assign()</strong><br><code>可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。</code><br>（2）<strong>lodash的clone方法</strong><br>（3）<code>...操作符</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;Kobei&#x27;</span>, <span class="attr">address</span>:&#123;<span class="attr">x</span>:<span class="number">100</span>,<span class="attr">y</span>:<span class="number">100</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> obj2= &#123;... obj1&#125;</span><br><span class="line">obj1.address.x = <span class="number">200</span>;</span><br><span class="line">obj1.name = <span class="string">&#x27;wade&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;obj2&#x27;</span>,obj2) <span class="comment">// obj2 &#123; name: &#x27;Kobe&#x27;, address: &#123; x: 200, y: 100 &#125; &#125;</span></span><br></pre></td></tr></table></figure>
<p>（4）<strong>Array.prototype.concat</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123;</span><br><span class="line">    username: <span class="string">&#x27;kobe&#x27;</span></span><br><span class="line">    &#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.concat();    </span><br><span class="line">arr2[<span class="number">2</span>].username = <span class="string">&#x27;wade&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>
<p>（5）<strong>Array.prototype.slice</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123;<span class="number">2</span></span><br><span class="line">    username: <span class="string">&#x27; kobe&#x27;</span></span><br><span class="line">    &#125;];</span><br><span class="line"><span class="keyword">let</span> arr3 = arr.slice();</span><br><span class="line">arr3[<span class="number">2</span>].username = <span class="string">&#x27;wade&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 3, &#123; username: &#x27;wade&#x27; &#125; ]</span></span><br></pre></td></tr></table></figure>
<h3 id="2、深拷贝的实现方式"><a href="#2、深拷贝的实现方式" class="headerlink" title="2、深拷贝的实现方式"></a>2、深拷贝的实现方式</h3><p>（1）<strong>JSON.parse(JSON.stringify())</strong><br>  可以处理数组和对象的深拷贝，但是不能处理函数和正则，因为这两者基于这两个函数处理后得到的结果不再是正则/函数**<br>  <strong>缺点：</strong><br>  <ul><br>    <li>会忽略undefined</li><br>    <li>会忽略symbol</li><br>    <li>不能序列化函数</li><br>    <li>不能解决循环引用的对象</li><br>  </ul>  </p>
<p>（2）<strong>lodash的cloneDeep函数</strong><br>（3）<strong>jQuery.extend函数</strong><br>（4）<strong>如果所拷贝的对象含有内置对象，但是不包含函数，可以使用<code>messagechannel</code>，可以拷贝undefined和循环引用的对象</strong><br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function structuralClone(obj) &#123;</span><br><span class="line">  return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">    const &#123; port1, port2 &#125; &#x3D; new MessageChannel()</span><br><span class="line">    port2.onmessage &#x3D; ev &#x3D;&gt; resolve(ev.data)</span><br><span class="line">    port1.postMessage(obj)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b.d &#x3D; obj.b</span><br><span class="line">&#x2F;&#x2F; 注意该方法是异步的</span><br><span class="line">&#x2F;&#x2F; 可以处理 undefined 和循环引用对象</span><br><span class="line">const test &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">  const clone &#x3D; await structuralClone(obj)</span><br><span class="line">  console.log(clone)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure></p>
<h3 id="3、手写浅拷贝：遍历-gt-直接等号赋值"><a href="#3、手写浅拷贝：遍历-gt-直接等号赋值" class="headerlink" title="3、手写浅拷贝：遍历=&gt;直接等号赋值"></a>3、手写浅拷贝：遍历=&gt;直接等号赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name : <span class="string">&#x27;深深地&#x27;</span>,</span><br><span class="line">    arr : [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj3=shallowClone(obj1)</span><br><span class="line"></span><br><span class="line">obj3.name = <span class="string">&quot;春娇&quot;</span>;</span><br><span class="line">obj3.arr[<span class="number">1</span>] = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] ; <span class="comment">// 新旧对象还是共享同一块内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是个浅拷贝的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowClone</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source.hasOwnProperty(i)) &#123;</span><br><span class="line">            target[i] = source[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;obj1&#x27;</span>,obj1) <span class="comment">// obj1 &#123; name: &#x27;深深地&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;obj3&#x27;</span>,obj3) <span class="comment">// obj3 &#123; name: &#x27;春娇&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;obj.hasOwnProperty，返回值是一个布尔值，即是否是obj的属性（原型上的是false)</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/01/26/%E9%98%90%E8%BF%B0%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/" data-id="cl32gzikc001fhwvqfaefgx23" data-title="阐述深浅拷贝" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/" rel="tag">ES6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TS/" rel="tag">TS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/" rel="tag">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E7%90%86/" rel="tag">原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/" rel="tag">安全问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/tags/JS/" style="font-size: 20px;">JS</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/TS/" style="font-size: 15px;">TS</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/%E5%8E%9F%E7%90%86/" style="font-size: 10px;">原理</a> <a href="/tags/%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/" style="font-size: 10px;">安全问题</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 15px;">面试题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/25/TypeScript-%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/">TypeScript-基础类型和变量声明</a>
          </li>
        
          <li>
            <a href="/2020/02/28/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/">Vue面试题整理</a>
          </li>
        
          <li>
            <a href="/2020/02/27/css%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98/">常考面试题1</a>
          </li>
        
          <li>
            <a href="/2020/01/26/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">深入了解观察者模式</a>
          </li>
        
          <li>
            <a href="/2019/12/19/Vue%E4%B8%AD%E7%9A%84computed%E4%B8%8Ewatch%E7%9A%84%E5%8C%BA%E5%88%AB/">Vue中的computed与watch的区别</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 刘晨曦的个人博客<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>